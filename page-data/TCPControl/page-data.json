{"componentChunkName":"component---src-templates-post-jsx","path":"/TCPControl/","result":{"data":{"site":{"siteMetadata":{"title":"Cho's Blog"}},"markdownRemark":{"id":"9efc28d3-1946-58e8-a2a3-2de57b179d47","excerpt":"TCP는 데이터 송수신 과정에서 신뢰성을 보장하기 위해 오류 제어, 흐름 제어, 혼잡 제어의 기능을 제공한다.  오류 제어: 재선송 기법 TCP는 신뢰성 있는 통신을 위해 오류를 감지하고, 오류를 감지한 세그먼트를 재전송하는 방법을 사용한다.  먼저, TCP가 오류를 감지하는 방법을 알아보자. TCP의 오류 감지 1. 중복된 ACK 세그먼트를 수신했을 때…","html":"<p>TCP는 데이터 송수신 과정에서 신뢰성을 보장하기 위해 오류 제어, 흐름 제어, 혼잡 제어의 기능을 제공한다. </p>\n<h2 id=\"오류-제어-재선송-기법\" style=\"position:relative;\"><a href=\"#%EC%98%A4%EB%A5%98-%EC%A0%9C%EC%96%B4-%EC%9E%AC%EC%84%A0%EC%86%A1-%EA%B8%B0%EB%B2%95\" aria-label=\"오류 제어 재선송 기법 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>오류 제어: 재선송 기법</h2>\n<p>TCP는 신뢰성 있는 통신을 위해 오류를 감지하고, 오류를 감지한 세그먼트를 재전송하는 방법을 사용한다. </p>\n<p>먼저, TCP가 오류를 감지하는 방법을 알아보자.</p>\n<h3 id=\"TCP의-오류-감지\" style=\"position:relative;\"><a href=\"#TCP%EC%9D%98-%EC%98%A4%EB%A5%98-%EA%B0%90%EC%A7%80\" aria-label=\"TCP의 오류 감지 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>TCP의 오류 감지</h3>\n<h4 id=\"1-중복된-ACK-세그먼트를-수신했을-때\" style=\"position:relative;\"><a href=\"#1-%EC%A4%91%EB%B3%B5%EB%90%9C-ACK-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8%EB%A5%BC-%EC%88%98%EC%8B%A0%ED%96%88%EC%9D%84-%EB%95%8C\" aria-label=\"1 중복된 ACK 세그먼트를 수신했을 때 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>1. 중복된 ACK 세그먼트를 수신했을 때</h4>\n<p>중복된 ACK라는 의미가 애매할 수 있는데, 다음 그림과 함께 이해해보자.\n<figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/blog/static/187e70c288d91e18818178ba2b57e66f/d703b/TC_1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 106.47058823529412%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAAC0ElEQVR42o2UyXLaQBCG9f7PklsuueQUrxiXwcEGCYEkCGLfDIhV7vTXeJS4yuXyVP1opun+e53xRNdiPpfhaCSz2UxOp9OXcDwe5fX1VeZqOxj0C1uPnyRJpBWG0m5Hslgs8GHKn4G12+0kiiIJw6ZE7bas12vxptOpdDodJZrLTL2hkOf5p2T8z+r1ehrdQBbLhX273a54k8lExuNxoRjHsYX+FUIIVquV7TebzZnwcDgYye3trdRqtQ9TdnVzy6WcZZk0m025vr4W3/eN3HMGo7embLdbq40jcaQ43u/2SrK1aLJsY/8jxxZylue8vby8nI32eyPlDPCKchzF0mj4kmi9A/22NLKJlsrZOucF4XK5fJeWW9QLR/yHs2yTyVYdbLc72WomkNEH18h3hG62HDhD5gDhSWXHw9FqzYQAUnY2nusYntyeaKhjmvZ0xkKJdcZarVDCZmBjVW/UtQkNGQyHpk9ZipQdCR6HqsBwUnS+1C5/K8M5AkpwHpv8lBfd/pCQlOkyV4n08vxkdVqtV7JerdXhUrNYWsPOHuRjQupCrSCDCAPI+/2+NPVKgeRPKn7QlDDwJVU50VlND/9sKREyz6XGbcEThAD5Qok7QSjjpCtRrS7D/qDoNGU5z2NmTcGWs0c0NIR7SbqcqedSgRKzdvXtu9z8+Cm/n57McaGjX3T+t7W7TOu5fjQFA2SG6USiRiCT4Ui6YVu/Q5nziGiKAH0ehVarZVFi41ErhNzJNE1tD5CDKI6kUqlKpVqV+/t7KZVupKr70t2dXFxemswPAkk1SvQ9ni5eiXq9rlerYXMXqAJ74Pvnva/XDUPmj/Pz87OBQDiTIVwe4XLAK+BPlNo6zIBBdkAvTmJ7kIHtO4k8Pj5a2uh7PDvg6vJKKg8Vi9DJHFw07F3kRQaKi4tf8lCpWCAebyAo6XtY1ro8aSed7KvgLS2Xy2b7F3WNLympQD83AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='수신 호스트 측이 받는 세그먼트의 순서 번호중 일부가 누락된 경우' title='' src='/blog/static/187e70c288d91e18818178ba2b57e66f/ca1dc/TC_1.png' srcset='/blog/static/187e70c288d91e18818178ba2b57e66f/e7570/TC_1.png 170w,\n/blog/static/187e70c288d91e18818178ba2b57e66f/f46e7/TC_1.png 340w,\n/blog/static/187e70c288d91e18818178ba2b57e66f/ca1dc/TC_1.png 680w,\n/blog/static/187e70c288d91e18818178ba2b57e66f/d703b/TC_1.png 786w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>수신 호스트 측이 받는 세그먼트의 순서 번호중 일부가 누락된 경우</figcaption>\n  </figure>\n위 그림처럼 만약 <code class=\"language-text\">n+1 세그먼트</code>가 손실된 상황이라면, ACK를 보내는 호스트는 <code class=\"language-text\">n+1 세그먼트</code>를 받지 못해 <code class=\"language-text\">n+1 세그먼트</code>에 대한 ACK를 2번 보내게 된다. 이럴때 호스트 A의 입장에서는 <code class=\"language-text\">n+1 세그먼트</code>에 대한 ACK를 <strong>중복하여 두번</strong> 받았으므로 <code class=\"language-text\">n+1 세그먼트</code>에 오류가 있음을 감지할 수 있는 것이다.</p>\n<h4 id=\"2-타임아웃이-발생했을-때\" style=\"position:relative;\"><a href=\"#2-%ED%83%80%EC%9E%84%EC%95%84%EC%9B%83%EC%9D%B4-%EB%B0%9C%EC%83%9D%ED%96%88%EC%9D%84-%EB%95%8C\" aria-label=\"2 타임아웃이 발생했을 때 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>2. 타임아웃이 발생했을 때</h4>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/blog/static/d16161b1043b1b7ddbd1585e48d6846f/51f47/TC_2.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 96.47058823529412%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAACm0lEQVR42o1TiU4iQRTs//8VNwYWgY0KKMhlHBTlvjRyzAw3ckrA2q7HNuC6JttJpV+/o169nh613W6x3W7Q7bp4fn7GYDDEZrPBzv89mMPluC6arRY6dkf8is7xeIxGo4HX11fUajUMh0NJZsLHx8cX0M81nU5Rr9fRbDalbjAY7Ag7nY4EuWazmZz/h7Db7YoYQ95ut3eEo9EI1WoVlUpF9n6//4XQjHpMOJlMUCqVpI4QhUwwHSj77e1NzseKuNbv73vbxLmYz7FJzqVMZxNcLBZYr9f7gtVqhVazJWjry69rJQ1NMJ0cGvOajL1XSNJeryfB+Xwu5MRcN+jZDtqVhkYd3Y6N6Wz66SVQnbEVvxA7uq4jl7xcLvGuxyNW2p5pchYUYynUkpZ+DXV5KpyCuZyAd8edUK4OchyStfRI/Gq8T4EonKNvuxjpD9V3XAycnjRhzOSRw9iKX5gK2MW8Jb5D7p+gfcPR8J8xTmlsZds2CKorFAp4eXmRs+M4AnZ3/9h8ZyzmO7WdQw5/CmPLHRIkPH5Txs7l8riJxhDTSMQT2r4Ru1QuC7GpMzyKb4hgl1wuJ2PTpo92WRcWi0UByZ+eniSPJAT92WwWhkeZAAszmQzy+fw+mahWqvL3EOVSWSsroZAvwLqzJD+RSAjMVOrx8REEO6fTaZgzuz48POD29lb8RDweF9C+syxYGUvy0qlDnbIY0Li/v8f19TUikYgUxWIxvd8gEAzgx8kJfL4zeE49+BUMwuvxwuP14qfPh1Rq18jwqGQyCYKBy8tLXF1daTu1hyjUO1Xt8lKfQF8kEobhUdFoFAZ+v19UHvsMwuHwt7FAILCPqVAoJMnn5+c40aMF9Ug8038Mqv/bR1xcXEjdmRbDut/7CmPOsqvIDgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='송신중인 세그먼트가 누락되어 타임아웃이 발생한 경우' title='' src='/blog/static/d16161b1043b1b7ddbd1585e48d6846f/ca1dc/TC_2.png' srcset='/blog/static/d16161b1043b1b7ddbd1585e48d6846f/e7570/TC_2.png 170w,\n/blog/static/d16161b1043b1b7ddbd1585e48d6846f/f46e7/TC_2.png 340w,\n/blog/static/d16161b1043b1b7ddbd1585e48d6846f/ca1dc/TC_2.png 680w,\n/blog/static/d16161b1043b1b7ddbd1585e48d6846f/51f47/TC_2.png 892w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>송신중인 세그먼트가 누락되어 타임아웃이 발생한 경우</figcaption>\n  </figure>\n<strong>타임아웃이</strong>란 이름 그대로 정해진 시간 내에 응답을 받지 못하는 상황을 의미한다. TCP 세그먼트를 송신하는 호스트는 모두 <strong>재전송 타이머</strong>라는 값을 유지하는데, 이 타이머의 카운터가 끝나는 상황까지 ACK를 받지 못했다면 오류라 판단한다.</p>\n<h3 id=\"ARQ-재전송-기법\" style=\"position:relative;\"><a href=\"#ARQ-%EC%9E%AC%EC%A0%84%EC%86%A1-%EA%B8%B0%EB%B2%95\" aria-label=\"ARQ 재전송 기법 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>ARQ: 재전송 기법</h3>\n<p>오류를 감지 했다면, 오류를 해결하기 위한 기능을 동작해야 하는데 TCP에서는 재전송 기법을 사용한다. 여기서 수신 호스트의 답변(ACK)과 타임아웃 발생을 토대로 문제를 진단하고, 문제가 생긴 메시지를 재전송함으로써 신뢰성을 확보하는 방식을 <strong>ARQ(Automatic Repeat Request, 자동 재전송 요구)</strong> 라고 한다.</p>\n<p>이 ARQ에는 크게 3가지 종류가 있다.</p>\n<ul>\n<li>Stop-and-Wait ARQ</li>\n<li>Go-Back-N ARQ</li>\n<li>Selective Repeat ARQ</li>\n</ul>\n<h3 id=\"Stop-and-Wait-ARQ\" style=\"position:relative;\"><a href=\"#Stop-and-Wait-ARQ\" aria-label=\"Stop and Wait ARQ permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Stop-and-Wait ARQ</h3>\n<p>가장 단순하면서 직관적인 재전송 기법이다. 이름 그대로 세그먼트를 송신한 후 제대로 전달 받았음을 확인하기 까지 기다리는 방식이다. 단순하지만, 높은 신뢰성을 보장하는 방식이라 할 수 있다.\n<figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/blog/static/513f0ecf946fce745fd95e92ddc83fe4/9a8ca/TC_3.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 101.17647058823529%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAADAUlEQVR42oVTiU5iQRCc//8W1ygRVoNynyqnIjcPHjcqGEAuj9qudofgbjY7SeX19HRXd830Mx8fH/j8/MRut0O318NoPMZ6s1Yfzw5x6Ht/fwfXcrnAaDTCaDjEdruDYRDXYNBHrV5Hs9FEt+Nq8v9AUsdx0Gw2Ua/VlNiQjN31+33Y5bqu+rj+Rcb1+vq6z6OvJwqNldFut9HpdNDtdrUiq/9FhO9rs9mgJp0xh7mEscFvb2/qqItsVrZd2LXdbpWAnW/lyz1j1us1qtWqkrIxcyiBpIvFQoOWy6XaxGq1wkTup9loSPct1IWg6bSl8Gov3T7SN0JWJxkXq7GAShd7I/7VeiVdbjVmvRKsN1Jwjslksr8iczgSlMRu7CVzMXA6nWL8+IhHwaDfw/Pzs05FX+yOTMRQRobFVbJWE5CM8sYyh7PZbI+npyeMJ2MMRfJgMJC7cvU1XbeDntzbk5C/vLzoFZHDkIR3wc6Y3JB7YgKTlXw6w3w+R0emoCEv2mi1ULq/R6X8oCPDPHbI4owzTK6UyzrUfGUOJyVRHm2eM7FerqAYS6EQS8KVYea9TcYTvQ6+MPfMM9w8lEry9BW0nJbOIw/Z3SF6vS5ywShSPj/SyYQWt3H8W1iUtrHyiHuRwkHln2IHVTuUs5YocGRknJYj3Vb1MTrtrx+Bc8hGaBv+FRZlkV4sFlGSjknO7xcekEwmEQ2FEInFEIpEELi6ws3NjRZlHhshh6lUKiBYhckk5CH39Fvyu7s7FAoFZLNZ5HI5ZDIZ3BK3t1qMpIw3DCSYxEAmWBKS246JfD7/mzCvNjtMpdKISMcsRh7DSkQ2m8H19TWCwQASicQeMZHo9XpxfHwM79kZPB6P7H369fl+4kqkx2JxJSePSaVSINLptCb7/X7E43EFpdAfCUcQDAS1k3AojDD3wSACgYDYYQTEZjx5TDQaBUGyy8tLXFxc7DuzZwwmmbWJhP1K7Pn5ueYyx7AKwYqU9OPoCNZ3CEoj/vQz7+TkBKeeU7FD+AUyiq2xdn8gKAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='Stop-and-Wait ARQ 흐름도' title='' src='/blog/static/513f0ecf946fce745fd95e92ddc83fe4/ca1dc/TC_3.png' srcset='/blog/static/513f0ecf946fce745fd95e92ddc83fe4/e7570/TC_3.png 170w,\n/blog/static/513f0ecf946fce745fd95e92ddc83fe4/f46e7/TC_3.png 340w,\n/blog/static/513f0ecf946fce745fd95e92ddc83fe4/ca1dc/TC_3.png 680w,\n/blog/static/513f0ecf946fce745fd95e92ddc83fe4/9a8ca/TC_3.png 868w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>Stop-and-Wait ARQ 흐름도</figcaption>\n  </figure>\n하지만, 이러한 방식은 네트워크의 이용 효율이 낮아질 수 있으며 성능 저하로 이어질 수 있기 때문에 오늘날의 인터넷 환경의 TCP에서는 잘 사용하지 않는 방식이다.</p>\n<h3 id=\"Go-Back-N-ARQ\" style=\"position:relative;\"><a href=\"#Go-Back-N-ARQ\" aria-label=\"Go Back N ARQ permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Go-Back-N ARQ</h3>\n<p>Stop-and-Wait ARQ의 문제를 해결하기 위해서는 각 세그먼트의 응답이 돌아오기 전에 일정한 개수의 세그먼트를 더 보낼 수 있어야 한다. 그래서 <strong>Go-Back-N ARQ</strong>방식은 연속해서 메시지를 전송할 수 있는 기술을 사용하고 있다. 이러한 연속해서 메시지를 전송하는 기술을 <strong>파이프라이닝</strong>이라고 한다.</p>\n<p>Go-Back-N ARQ방식은 파이프라이닝 방식을 사용하려 여러 세그먼트를 전송하고, 도중 잘못 전송된 세그먼트가 발생하면 <strong>해당 세그먼트부터 전부 다시 전송</strong>하는 방식이다.\n<figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/blog/static/59fe1db012a89f7b1995ee9a663439d1/fa6a4/TC_4.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 62.94117647058823%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACAUlEQVR42m1R2W7iQBD0/3/NRhuJFw6Fw2Y5DAQbG7OAucKNbW5x1XY3GUJWGanUM93V1TUz2u12gwKvyXiC0WiE6/X6Iy6Xi/C22y1838d6vZazqmsPMcL5fCbBMYbDIQ6Hw2OQIqs9rzAM0ev1sFqt5Kxq2v8ON5sNFosF9vu9QLliKGFePHw2mz3OyuU3QTWFRaMokms9X1fVT6eTgOubzRpBEGK32/0syJPXJBYEgTg9Ho8CfoLoM8/X3JAYv9+OYhTeh3OvxsRncCFYLBEuVthG94YtORah5VLeLiSB6XSGj4+x5Mb0kZPJlAaG0AIhfGE+n2PQ9eG7Htq2Ky4HfzuwSybanTa63S6azSY6FFmEXSqwc61PzT36/h5F3vf9njQNBgN02m1Bl+DYDVQrVbxXa6iaFYpVeE1PuK1WC57n0a/3oXlukwpNtKjoua5Mt20bHpMEnpAbjQZKpRLK5TKsev3Osyw4lGe+ZdnC05jYcByBQ3iv1VAsFslNBaZpokZOWKBOzRY1uiTk0mAWqRHXdVzpc1xHcho3PUAihUIBek7HH92AkclCT2eQz+ZglsrirvzpkpHP5/HczzfQdF3HM7LZLN7SbzDyxiOXy+Uk/4xMOo1kMgnD+M7TEokEFJgQi8Xw+vsVqVTqkU/Ev+oKiXgcL79eEKeoeLz/B57OtYaFr7/VAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='Go-Back-N ARQ 흐름도' title='' src='/blog/static/59fe1db012a89f7b1995ee9a663439d1/ca1dc/TC_4.png' srcset='/blog/static/59fe1db012a89f7b1995ee9a663439d1/e7570/TC_4.png 170w,\n/blog/static/59fe1db012a89f7b1995ee9a663439d1/f46e7/TC_4.png 340w,\n/blog/static/59fe1db012a89f7b1995ee9a663439d1/ca1dc/TC_4.png 680w,\n/blog/static/59fe1db012a89f7b1995ee9a663439d1/02d09/TC_4.png 1020w,\n/blog/static/59fe1db012a89f7b1995ee9a663439d1/9d567/TC_4.png 1360w,\n/blog/static/59fe1db012a89f7b1995ee9a663439d1/fa6a4/TC_4.png 1412w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>Go-Back-N ARQ 흐름도</figcaption>\n  </figure>\n수신받는 호스트(호스트 B)는 수신받지 못한 세그먼트(n + 2 세그먼트)가 있을 경우, 다른 세그먼트(n + 3 세그먼트)들을 정상적으로 수신 받더라도 수신받지 못한 세그먼트 이외의 모든 세그먼트를 폐기한다. 송신 호스트(호스트 A)에서는 ACK를 받지 못해 타임아웃이 발생하며 잘못된 세그먼트부터 다시 전송하게 되는 것이다.</p>\n<p>Go-Back-N ARQ의 확인응답(ACK)은 n번까지의 확인 응답을 누적해가며 보내기 때문에 <strong>누적 확인 응답(CACK)</strong> 이라고 한다.</p>\n<h3 id=\"Selective-Repeat-ARQ\" style=\"position:relative;\"><a href=\"#Selective-Repeat-ARQ\" aria-label=\"Selective Repeat ARQ permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>Selective Repeat ARQ</h3>\n<p>Selective Repeat ARQ의 이름대로 <strong>\"선택적으로 재전송\"</strong> 을 하는 방법이다.</p>\n<p>앞서 설명한 Go-Back-N ARQ 방식에서는 한 세그먼트에만 문제가 발생하여도 그 후의 모든 세그먼트를 다시 재전송 하는 단점이 있는 반면, Selective Repeat ARQ 방식에서는 수신 호스트 측에서 제대로 전송받은 <strong>각각의 패킷들에 대해 ACK</strong> 세그먼트를 보내어 문제가 있는 세그먼트만 재전송 하는 방식이다.\n<figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/blog/static/be1386579ba302a42a31f7c8ef5cc43b/9c259/TC_5.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 80.58823529411765%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACSUlEQVR42n1S2ZKiQBDk/39In7xnlXFHnTBm8BoRQQRFkVvxyK1qxRDX3Y7IoKsqOyu7aOlyuSADr/1+D32uw9t5In6sP/I8z8N8PkccJ3fe+XyGlJE44OW6riA7aycnyPXHveM42O12gv9SMMPxeIRu6NhsNkiSRMScP51OOYdBEAiHh8Ph/4IMJvHVA99HmqaCmCETzHhZszN/XwnyYmd8Hdu2EYahED3SIXYbx7Fwx3nP98R4POJGlP+nw4SK+zDCPqIrsxgJRSTC8/LJdRTFQni73QpR190KYW4sZa6yxXHE3Z0N1pqBJGDhCOvBiFx7JBZhtVphYRiiAbtK04NoyleXUppDEoSIbzhQ55DciDny3g/IHdX8EA4JWaZFDSMhwKNJ0+N1JMfrTSS2zo4icsJz4f2W/vCOrhCSm5gOMfbUgJsk9O78jYuVYWJpLLBaUxPLItc2zdaHxLZz2LqwlhbWqzU5ItABfpO2ZUMbTzAbjaFPVCzoySyXS5qdL36g5+3ETCVO5kDd1KmKn+GYMMLkW4FGMc9M1+YwFyZscmPZFrSbqGma9680m83wjNFoJEQ1TcOMoc4EVFUVmP5MMSG3A2Vw5dzOcU0aDAZ4Rr/fh/Ii//31hf7nJ3q/P9B5b6Pb6WI4HN7riqJA6vV6eEa7fSVf0bmhi3ZLRluW0fkgQcox7/Fct9uF1Gq18Ix6vY5fb29/5eV3GbJ8BceNRiNXbzabkKrVKh5Rq9VQLBZRKpXEPsuXy+Ucr1KpoFAooFKt5HJ/AH9mpwYqsO8yAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='Selective Repeat ARQ 흐름도' title='' src='/blog/static/be1386579ba302a42a31f7c8ef5cc43b/ca1dc/TC_5.png' srcset='/blog/static/be1386579ba302a42a31f7c8ef5cc43b/e7570/TC_5.png 170w,\n/blog/static/be1386579ba302a42a31f7c8ef5cc43b/f46e7/TC_5.png 340w,\n/blog/static/be1386579ba302a42a31f7c8ef5cc43b/ca1dc/TC_5.png 680w,\n/blog/static/be1386579ba302a42a31f7c8ef5cc43b/02d09/TC_5.png 1020w,\n/blog/static/be1386579ba302a42a31f7c8ef5cc43b/9c259/TC_5.png 1272w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>Selective Repeat ARQ 흐름도</figcaption>\n  </figure>\n각각 패킷의 ACK를 보낸다는 점에서 Selective Repeat ARQ의 ACK는 <strong>개별 응답 확인</strong>이라고 한다.</p>\n<p>오늘날 대부분의 호스트는 TCP 통신에서 <strong>Selective Repeat ARQ</strong>를 지원하며, <strong>Selective Repeat ARQ</strong>가 지원되지 않는 호스트의 경우 <strong>Go-Back-N ARQ</strong> 방식으로 동작한다.</p>\n<h2 id=\"흐름-제어-슬라이딩-윈도우\" style=\"position:relative;\"><a href=\"#%ED%9D%90%EB%A6%84-%EC%A0%9C%EC%96%B4-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%9C%88%EB%8F%84%EC%9A%B0\" aria-label=\"흐름 제어 슬라이딩 윈도우 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>흐름 제어: 슬라이딩 윈도우</h2>\n<p>오류 제어 기법중 바이프라이닝 기반의 재전송 방식이 정상적으로 동작하려면, 호스트가 한 번에 받아 처리할 수 있는 세그먼트의 양이 정해져 있기 때문에 흐름 제어를 반드시 고려해야 한다. </p>\n<ul>\n<li><code class=\"language-text\">수신 버퍼</code>: 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 전에 임시로 저장되는 공간</li>\n<li><code class=\"language-text\">버퍼 오버플로</code>: 수신 버퍼 크기보다 많은 데이터가 전송되어 세그먼트가 처리되지 못하는 상황</li>\n</ul>\n<p><strong>흐름 제어</strong>는 위와 같은 수신 버퍼의 오버플로를 방지하기 위해 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 유지하는 것을 의미한다. 대표적인 방법으로 <strong>슬라이딩 윈도우</strong>를 사용한다.</p>\n<p>슬라이딩 윈도우란, <strong>윈도우</strong>라는 송신 호스트가 파이프라이닝 할 수 있는 최대량을 정해두고 이를 이동시키며 흐름을 제어하는 방식이다.\n<figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/blog/static/8462b680026f49ba49dfa54f0232ad82/3e7c2/TC_7.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 25.294117647058822%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA30lEQVR42oWO2W6DMBRE+f//awooBJt4X5HCJoQ0vXbShz7V0tHMvTbDNMe+Y99+2f5Cd8dx/Mt5nlBawliDxk0CZuQEgxrGj+fQA4MXCjkEZB+qJu+RnMdMc3QOc4xEop3Duiy4rguN5k/oB4U9RsgSyCbyrO7cUyIZ8w6xDl4qRK2rj9pgLqHWI/AJ27qinBqoqJFiHGPXQ1BomQX9wFJAohaR2sXw1vDBU1igxkW9tcg547W80AghIKWEIu7DHZzzOjPG0Pcdvr5vuBEt+bZrK+UbpRRkgd4WFaRl/wOEVXWViR/zCAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='윈도우가 4인 상태의 초기 상태,' title='' src='/blog/static/8462b680026f49ba49dfa54f0232ad82/ca1dc/TC_7.png' srcset='/blog/static/8462b680026f49ba49dfa54f0232ad82/e7570/TC_7.png 170w,\n/blog/static/8462b680026f49ba49dfa54f0232ad82/f46e7/TC_7.png 340w,\n/blog/static/8462b680026f49ba49dfa54f0232ad82/ca1dc/TC_7.png 680w,\n/blog/static/8462b680026f49ba49dfa54f0232ad82/02d09/TC_7.png 1020w,\n/blog/static/8462b680026f49ba49dfa54f0232ad82/9d567/TC_7.png 1360w,\n/blog/static/8462b680026f49ba49dfa54f0232ad82/3e7c2/TC_7.png 2206w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>윈도우가 4인 상태의 초기 상태,</figcaption>\n  </figure>\n위 사진은 윈도우 크기가 4인 상태의 슬라이딩 윈도우 초기 상태이다. 해당 상태에서는 첫 번째 ~ 네 번째 세그먼트만 동시에 보낼 수 있다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/blog/static/3c8e91783ab74168b2090f36d349384a/3e7c2/TC_8.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 25.294117647058822%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA9UlEQVR42l2Q7XKCMBBFef/n0xZGBQn5EhMoxVJBndMlju1Mf5y5m53dm5tky7IwzzPT5cI0Xv5U+Eo68j1NXJeZq8yts9d/LLcbIbQorcj6vsc6i6tqzKGi2R3Q+xJXVklVscOrhv4cOFtLd2qTBufp25bgvfROjMMH9/udLMaA8w57rLHJcI9JhjVazFfDVhs+QyTK4iDGUUyiP0kvpAuG9sz4MfB4PMi6rpO4ASspXK2wwj4vUJLQHEpMdcRbR4wxzSWVEL91eNbrS0f5nqxpGrTWGGOeWEN5lKTSX6mVIi8KNm9bNtst73lOLqz62n2xnn8Azsh0z/gU1nYAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='첫 번째 세그먼트의 ACK를 받은 상태' title='' src='/blog/static/3c8e91783ab74168b2090f36d349384a/ca1dc/TC_8.png' srcset='/blog/static/3c8e91783ab74168b2090f36d349384a/e7570/TC_8.png 170w,\n/blog/static/3c8e91783ab74168b2090f36d349384a/f46e7/TC_8.png 340w,\n/blog/static/3c8e91783ab74168b2090f36d349384a/ca1dc/TC_8.png 680w,\n/blog/static/3c8e91783ab74168b2090f36d349384a/02d09/TC_8.png 1020w,\n/blog/static/3c8e91783ab74168b2090f36d349384a/9d567/TC_8.png 1360w,\n/blog/static/3c8e91783ab74168b2090f36d349384a/3e7c2/TC_8.png 2206w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>첫 번째 세그먼트의 ACK를 받은 상태</figcaption>\n  </figure>\n이 후, 만약 첫 번째 세그먼트의 ACK를 받았다면, 윈도우는 다음 세그먼트의 방향(그림에서는 오른쪽)으로 이동하여 다른 세그먼트를 범위에 포함시킨다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/blog/static/b15e4b17fb040c86689deedcb15704fa/3e7c2/TC_9.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 25.294117647058822%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA7klEQVR42m2P23qDIBCEff/ns0mNSFIFQQ7aaGoDJk4Xa3PVi/8bWGaH3SzGBTFGhBBIA+Z5xvfO/LWfdw3hjpC8G+GlcVlgrIFQElk/9FCdhnUWWmvUJ4aGaKszmrJCXZSvmq5rDMbCyBZOafTGwHeE7jCNIx7PBzJHQUqr7QdNmkIE41DnC1rSpmSQFC4I0wiMzsNTWAq5WoeeAj+J23XEuq7IvPdwztGEhLUQFCQvH2gJlueQdBf8t2ZoA+/7zZ/4600Mw4BpmpAJISCl/JeK07T0XtOqnHMUpwL5W473osDxeMCBYIxt3uRL/AARgHThbxSz1wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='두 번째 세그먼트의 ACK를 받은 상태' title='' src='/blog/static/b15e4b17fb040c86689deedcb15704fa/ca1dc/TC_9.png' srcset='/blog/static/b15e4b17fb040c86689deedcb15704fa/e7570/TC_9.png 170w,\n/blog/static/b15e4b17fb040c86689deedcb15704fa/f46e7/TC_9.png 340w,\n/blog/static/b15e4b17fb040c86689deedcb15704fa/ca1dc/TC_9.png 680w,\n/blog/static/b15e4b17fb040c86689deedcb15704fa/02d09/TC_9.png 1020w,\n/blog/static/b15e4b17fb040c86689deedcb15704fa/9d567/TC_9.png 1360w,\n/blog/static/b15e4b17fb040c86689deedcb15704fa/3e7c2/TC_9.png 2206w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>두 번째 세그먼트의 ACK를 받은 상태</figcaption>\n  </figure>\n위 과정을 반복하며 윈도우가 마지막 세그먼트까지 이동하여 송수신의 흐름을 제어한다.</p>\n<p>송신 호스트 뿐만 아니라 수신 호스트도 윈도우를 고려하며, 두 호스트의 윈도우 크기는 수신 호스트에서 TCP 세그먼트의 <strong>윈도우 필드</strong>를 통해 공유한다.\n<figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/blog/static/dfdba83c615b8d75af6750ae1cee7ea8/e0a8c/TC_10.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 72.94117647058825%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACGElEQVR42o1S2Y7aQBCc//+WiOQBViKrtVeAuW+J28bmWCBgk3DfVKZa8iqbjSJGKk1PH9U1PaNW61/YbLdY+HP4gY/r7Yb7/f4Qlj+XGoHsP+ZzcKnhaACn76Dd6cB2bFwuFwk8QtjXdT27i063C8ft46bFKLffx1Yr3O12mEwm2Gmb6/YfpVzMn06nsu81xuMxNpsNVK/XE1UkeBu/YbVafSJk/G9CFo9GI1yvV/HRZq0aDocoFArI5/P6Cn3peD6fhYT78XiU4tPp9AGHwwGu60ptsVgEefb7PRQDs9kMnudJEglX6xWCZYD1ev1+JYL2ZrsRP8fEfCojaNOngiCA7/twHAeDwUCIPc+FlbVgJl9RqVVhc/j6wUZ6TovFXJqxbrlcytw5S9rkUVTHDl39UgxyuCS2bRutVgtVTVgoFpC0EjBeDZQrZWSyaXg6Z7FYiABenTwkViSjo9lsCjHJOA/aJB/rPTzzFmzSaDQEzWYL2WwOfFjmMk8xqaP/YK1WkwIqY0IInkMfdz4cEcar1aqQ08e44qFer8srU2XY/RG0221UKhWUy+V35YodSqUSLMsSlTw/CubncjlBWKv4jzKZDIwXQ/4Tg1T7J/7lI5ifSCQEtOlTVPb8/B3RaFRUplKpD0gmkzBN85OfSKfTiMfjiMZiujYtPmUaJmKxKCLfvuJFqzSMx8Hap6cYvkQiMHRT+n4DkDg5q5oyzmsAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='수신 호스트에서는 TCP의 윈도우 필드를 통해 윈도우 크기를 공유한다' title='' src='/blog/static/dfdba83c615b8d75af6750ae1cee7ea8/ca1dc/TC_10.png' srcset='/blog/static/dfdba83c615b8d75af6750ae1cee7ea8/e7570/TC_10.png 170w,\n/blog/static/dfdba83c615b8d75af6750ae1cee7ea8/f46e7/TC_10.png 340w,\n/blog/static/dfdba83c615b8d75af6750ae1cee7ea8/ca1dc/TC_10.png 680w,\n/blog/static/dfdba83c615b8d75af6750ae1cee7ea8/e0a8c/TC_10.png 998w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>수신 호스트에서는 TCP의 윈도우 필드를 통해 윈도우 크기를 공유한다</figcaption>\n  </figure></p>\n<p>결과적으로 송신 호스트는 송신하는 세그먼트를 기준으로 윈도우를 이동시키며 혼잡 제어를 진행하고, 수신 호스트는 수신 받은 세그먼트를 기준으로 윈도우를 이동시키며 혼잡 제어를 진행한다.\n<figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/blog/static/5833d2d9769915c9d21f6117a63eefeb/d76be/TC_11.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 55.294117647058826%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB/0lEQVR42nVS2W7aUBD1/39EpbR9SKXQ51ota8AEOwTXEINjFuMlXsBL2PfTuTeiCqgd6Xiux3NnzpyxcDqdcI3j8YAoiuB5Hna73Yf4EdEkgh/42O/3YHZ9V2CPs53PLHk6nSJLU6zX67/Jm82Gx5MkxWq1+nfB3WqNzXKFWZYhDF4xn89xOBwQ08U4jvklxoyBWUpNzvFr4wUHTRVNsYBHgv6gwLXGsIcj8jYWVHy5XGK73V6wZ6y3hMXbG3ySJctSLs2O8i5G/miMJSvEmDE/m81o1IQ3sMYW1IqE1q8yFDEPU9U4Ed9xITBNTLUNQ35Ct9GE/WJi4gcIeOeMszmzYhpyJoT/mcA08YYWPHMI1xwgevWRkegJFz+BH/qYxlMsFgvegOkXhNQwCGAbJizdIPQQOB7SOIGQUEJCGkwmE0wJURC+e/ptwjBESkX4FIM+5CcFPcOA2e9zr9VlqLUHtKp1vHSeMR5ZEFpqC5IkQfyWg3ibw4/bO0iFEpqKAp2SDL2LgdnHeEzLsm2O0YiW5rpwSRbHceC4DsXZdweCruvodrsX6PW66HQ60H5reG63obVU/s5y25qGYrGIQqmEn6KIu0+f8f3mC3I3X3GfL0KQZRlnNDga/FytVlGu0BYflfd4g+LEukbxQj5PU9VRva+iUiyhTA2Yl2o1/AGV2CsaO7bB1wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='송수신 호스트의 슬라이딩 윈도우' title='' src='/blog/static/5833d2d9769915c9d21f6117a63eefeb/ca1dc/TC_11.png' srcset='/blog/static/5833d2d9769915c9d21f6117a63eefeb/e7570/TC_11.png 170w,\n/blog/static/5833d2d9769915c9d21f6117a63eefeb/f46e7/TC_11.png 340w,\n/blog/static/5833d2d9769915c9d21f6117a63eefeb/ca1dc/TC_11.png 680w,\n/blog/static/5833d2d9769915c9d21f6117a63eefeb/02d09/TC_11.png 1020w,\n/blog/static/5833d2d9769915c9d21f6117a63eefeb/9d567/TC_11.png 1360w,\n/blog/static/5833d2d9769915c9d21f6117a63eefeb/d76be/TC_11.png 2028w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>송수신 호스트의 슬라이딩 윈도우</figcaption>\n  </figure></p>\n<h2 id=\"혼잡-제어\" style=\"position:relative;\"><a href=\"#%ED%98%BC%EC%9E%A1-%EC%A0%9C%EC%96%B4\" aria-label=\"혼잡 제어 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>혼잡 제어</h2>\n<p>TCP에서는 혼잡 제어를 위해 <strong>혼잡 윈도우</strong>의 크기를 계산하는 알고리즘을 가지고 있다. 이러한 알고리즘을 <strong>AIMD</strong>라고 한다.</p>\n<p><code class=\"language-text\">혼잡 윈도우</code> - 혼잡 없이 전송할 수 있을 법한 데이터의 양</p>\n<p>AIMD는 Additive Increase/Multiplicative Decrease의 약자로, \"합으로 증가, 곱으로 감소\"라는 의미이다. 혼잡이 감지되지 않는다면 혼잡 윈도우를 <em>RTT</em> 마다 1씩 선형적으로 증가시키고, 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 동작을 반복하는 알고리즘이다.\n<figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/blog/static/e2e0fe72fc37a20f68502e6a395cf8da/b0f6f/TC_12.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 51.764705882352935%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABYElEQVR42qWQSY+CQBSE+///Iudg4jIRGJdmEZBFJrKNmDHgQT2oqXmvA2ZCMpmDhy/1+lV1NUEcj9+4XC54PB643W643+8vIYosQ13XuF6vOJ/PqvwVhOd5qKoKp9MJddOgofKGlc5K+/D+L48QYRAiy3IcDgfs93tUpF9liTzN1I4f6+BzWZQo2nzV8xmRpim2cUylGbI8B5+jIEASxSjyArvdTu1y9miOgwhJvEVBj35uE0Xe3uMOEVOZuZKIowgR4a89RGGIcBOQRnAsC5wJaed7vsqE9CDjr902FyLYbJAkCYTrupCrFVxnDUtK8D9l5GIJm8ocy1bY0oTv+/A4T55j2yrHH8O57p6QpoSuaZgbBkzThEUm63KxUPP84wNz3YDVeZK9ZTtL5Zk8t/eEQUXv0yk0KtV1/akd2mwGjWfK9b0+3CWmVDYejzEajf6Fc7+ZTCZPHQ6HeBsM8ANu7M6S84QiQgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='혼잡 윈도우는 톱니 모양으로 변화한다' title='' src='/blog/static/e2e0fe72fc37a20f68502e6a395cf8da/ca1dc/TC_12.png' srcset='/blog/static/e2e0fe72fc37a20f68502e6a395cf8da/e7570/TC_12.png 170w,\n/blog/static/e2e0fe72fc37a20f68502e6a395cf8da/f46e7/TC_12.png 340w,\n/blog/static/e2e0fe72fc37a20f68502e6a395cf8da/ca1dc/TC_12.png 680w,\n/blog/static/e2e0fe72fc37a20f68502e6a395cf8da/02d09/TC_12.png 1020w,\n/blog/static/e2e0fe72fc37a20f68502e6a395cf8da/b0f6f/TC_12.png 1042w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>혼잡 윈도우는 톱니 모양으로 변화한다</figcaption>\n  </figure></p>\n<blockquote>\n<h4 id=\"RTT\" style=\"position:relative;\"><a href=\"#RTT\" aria-label=\"RTT permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>RTT</h4>\n<p>RTT(Round Trip Time)란 메시지를 전송한 뒤 그에 대한 답변을 받는 데까지 걸리는 시간을 의미한다.\n<figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/blog/static/436724451e24643ccd2b3f7488309aba/1745e/TC_6.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 65.88235294117646%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAABGElEQVR42n2SWY6DMBBEff+T8YXEAdgGBAKxiH0Nnjd2BnmcZOrDMumu6qqOhfyLqqp83x+GQX7AeZ5ZlkVRtG2bMAvLsoRhWNd1HMfULNp1XZxlWUIuiiJNU2EWxnFEct93JOZ5Nmka3JMkaZoGa0EQCEsbmuM4aN8/PhTuAbjzPM91XfjC8kZf13V0MB/nmsbnNE14gUDmdV11KJtM4e7QHJDn+ZcCl/UXP+Q7DwRW1fc9ybVDM/BxHHhBjirbepL5JmGlgDCeLbLm4x91mqEx40m2bBPGDMYdRdQ5+ZMYwKrbtsXFGzIT6NBlyJzwWwVMMfM/MqBbL/kTWPt72wBtM/OpYL4T9q/fr3h9umR73bY1Gf9Sym/Lt/QuBGZ9HQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='RTT' title='' src='/blog/static/436724451e24643ccd2b3f7488309aba/ca1dc/TC_6.png' srcset='/blog/static/436724451e24643ccd2b3f7488309aba/e7570/TC_6.png 170w,\n/blog/static/436724451e24643ccd2b3f7488309aba/f46e7/TC_6.png 340w,\n/blog/static/436724451e24643ccd2b3f7488309aba/ca1dc/TC_6.png 680w,\n/blog/static/436724451e24643ccd2b3f7488309aba/1745e/TC_6.png 814w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>RTT</figcaption>\n  </figure></p>\n</blockquote>\n<p>AIMD로는 완벽한 혼잡 제어가 불가능 하기 때문에, 이를 보조할 혼잡 제어 알고리즘들이 있다.</p>\n<ol>\n<li>느린 시작</li>\n<li>혼잡 회피</li>\n<li>빠른 회복</li>\n</ol>\n<h3 id=\"느린-시작-알고리즘\" style=\"position:relative;\"><a href=\"#%EB%8A%90%EB%A6%B0-%EC%8B%9C%EC%9E%91-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"느린 시작 알고리즘 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>느린 시작 알고리즘</h3>\n<p>느린 시작 알고리즘은 혼잡 윈도우를 1부터 시작하여 문제없이 수신된 ACK 세그먼트 하나당 1씩 증가시키는 방식이다.</p>\n<p>아래 그림과 같이 RTT마다 2배씩 증가하며, 이는 AIDM에서의 혼잡 윈도우 증가 속도보다 빠르다는 것을 알 수 있다.\n<figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/blog/static/c7c1bb112e9e9a25e94c4ca176de1c51/b38ab/TC_13.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 81.76470588235294%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACj0lEQVR42nWT208aURDG9/9/60Nf2kaTpmli0kRNbBFFdkWBRe4ggnJTubMgLMgd/DrfgTVg05P8Mucy852Z2bPa29sbtlmtVuDo233UajUMh0O15v62T7fbRavVwmQyUefOmfZfwX4fzWZzR3C5XKr5fD5Hu20J7X8u3BHkGNkD2FYH09kU9Xod0+lUCTHACeKgkGVZW8lgV5CDIk+lMqx6A9yh2ELEmNFsNlNMhcVi8b7mZS8vLyIu2Q4GuxluZ8A5A5zhlLykmFw0en3FeDxeZzuw0ev1lM+HHkrvpDfjwRArWYxHIxW8kAw/lkzx+ebCbQ2N5RCW8Sq3RnQfKoWSKrUnpfDjDKQU27YV9JnIJbSEcY4G0dhcB6bdkedgiwBFuGYQLfu07pWFpvS48vysvvJIqqCvo6F1Oh0oRKgrAXxfhM7Vag0N+dIteT5teXN8d61mCx0R5ZrPinHvGoJWq1ZRbzRQfMgj4PZAPz7BbSyOqjzqXDaH/P09CoUC8vk8isUinp+eUKlUUC6XFXxa/AEctFKpBFKQgPhNGNdeHelUSjlns1lkMhmk02lF5lbmqTQSiQSikYg6e3x8VBc5Otrd3R0Ig3MPD7gXcrmc2ksmkkoolUwqYtEowjc3SixkhhCPx5UvYx003kboTIekBKp1LAYzGEQkHBaB6MZG1n7SkojMw7Ln+Dtohz9+4te3fRx83cPBlz18//QZvw+PEDRNXBoGAn4/goGAEg8KZshEKBRSc7+cmeK3jWace0AuPRfwuE5xcnQM79k5rnQdF+4zsYaaE5/XK+gKQ/x1ieO52tPXaKfXlyCujXX7r5T949NxeO4Wa8B1tYZ7tKfCiXGBI497Hbs5d/kM/AVoOJIMUDl4jQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='1이였던 혼잡 윈도우는 최종적으로 8이 되었다' title='' src='/blog/static/c7c1bb112e9e9a25e94c4ca176de1c51/ca1dc/TC_13.png' srcset='/blog/static/c7c1bb112e9e9a25e94c4ca176de1c51/e7570/TC_13.png 170w,\n/blog/static/c7c1bb112e9e9a25e94c4ca176de1c51/f46e7/TC_13.png 340w,\n/blog/static/c7c1bb112e9e9a25e94c4ca176de1c51/ca1dc/TC_13.png 680w,\n/blog/static/c7c1bb112e9e9a25e94c4ca176de1c51/02d09/TC_13.png 1020w,\n/blog/static/c7c1bb112e9e9a25e94c4ca176de1c51/b38ab/TC_13.png 1168w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>1이였던 혼잡 윈도우는 최종적으로 8이 되었다</figcaption>\n  </figure></p>\n<p>하지만, 매번 2배씩 혼잡 윈도우를 증가시킨다면 언젠가는 혼잡 상황을 마주할 확률이 높아지므로 <strong>느린 시작 임계치</strong> 값을 설정하여 이를 방지한다. </p>\n<p>아래는 상황별 혼잡을 피하는 방법에 대한 표이다.\n<span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/blog/static/370419a113694969982ecf3eaa1f87f6/5e75c/TC_14.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 21.176470588235293%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA6klEQVR42nWOS0/CUBCF+/9jAB+IgAq6M8Zo24hCpbelt7fFQEKhr4UsaX/GZ3sTly5OzpzMzDdjiP4EcXmHenzW8q4meNdTvi5ucc7HOL0xbtPXuTdCDB5Y9u9ZdG6Yd4Y43RGL7pD52YBw+oRRFAW7JOHneKSua6qq4nSqiOMIf+UjQ4mKY7brb9YyJAgCsizjkB5Imr22TvZ70izVDKMdEEIQRRFKKb2w2W50boEr30ctBUpKkl1CnucUZalVtt489JdbqPExm2Gab1iW1biJ67oaatu2zrZp8fnyynvTF56nj8oG/p9+Aby5A6MQqw6MAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='TC 14' title='' src='/blog/static/370419a113694969982ecf3eaa1f87f6/ca1dc/TC_14.png' srcset='/blog/static/370419a113694969982ecf3eaa1f87f6/e7570/TC_14.png 170w,\n/blog/static/370419a113694969982ecf3eaa1f87f6/f46e7/TC_14.png 340w,\n/blog/static/370419a113694969982ecf3eaa1f87f6/ca1dc/TC_14.png 680w,\n/blog/static/370419a113694969982ecf3eaa1f87f6/02d09/TC_14.png 1020w,\n/blog/static/370419a113694969982ecf3eaa1f87f6/9d567/TC_14.png 1360w,\n/blog/static/370419a113694969982ecf3eaa1f87f6/5e75c/TC_14.png 2154w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<h3 id=\"혼잡-회피-알고리즘\" style=\"position:relative;\"><a href=\"#%ED%98%BC%EC%9E%A1-%ED%9A%8C%ED%94%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"혼잡 회피 알고리즘 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>혼잡 회피 알고리즘</h3>\n<p>혼잡 회피 알고리즘은 RTT마다 혼잡 윈도우를 1MSS씩 증가시키는 알고리즘이다. </p>\n<p>이름 그대로 혼잡을 회피하기 위해 <strong>느린 시작 임계치를 넘어선 후</strong>, 선형적으로 혼잡 윈도우를 증가시키는 방법이다.\n<figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/blog/static/472968973302d625118374f1b31f9a43/f7f62/TC_15.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 68.23529411764706%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB0klEQVR42p2RC4+aUBSE7///Ne0m3VShrhgfjaKmyxqjJouPFVQUcBXF5/ScU9lQatKmJF/uZZg7cwA1n83hr5YIwhCn0wmXy+W/OZ/PUNE2wmazkbDr5Yrr9d/g656uOGy/34sh3ZY1Ho9HKU2C4jjGhSb6I3BLgbvdDtkrPQmHOY5Dn2Ylb7Oidb1ei86e9BBq8/4upiiKMJ/PMZvN5HC8j2Vy0UnzFh4F+VJ+OBw+vhlPncAFarX04HmeNPq+L+2+z5NsJYjDQ/phQRAgDEK4zhTj0Qi2/YrRaCzPR/YQ07c3yVC8cV33FuR/wPcz0pM943lLKedp+W0Wi4Xcy7r4NZga2jbs4VCaErhgMp5gQhPwPv1MIM29kfgdl/SpA9Xr9cAMKTTNgDR+raz+N5T1bOGZ4NBut4t2u42OZcFq/8BgMEC/3/+NREsGyaJazSZM08RLp4OG2UCjXodZNyW41Wqh3iCNYE+TvLxvkm5x6R3U91oNNULMFFYxSnKIqVarMEolFItPtBool8tyX6lUxX8PZRgGdE3Dk/4NxUKBzBWBw5jarTAN64kviypQyNfHR+RyOWi6hnw+LwW8spZes+i6Do28X+j8p88PyOXz+AkwKP6733iqBgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='느린 시작 임계치 넘음 -&gt; 혼잡 회피' title='' src='/blog/static/472968973302d625118374f1b31f9a43/ca1dc/TC_15.png' srcset='/blog/static/472968973302d625118374f1b31f9a43/e7570/TC_15.png 170w,\n/blog/static/472968973302d625118374f1b31f9a43/f46e7/TC_15.png 340w,\n/blog/static/472968973302d625118374f1b31f9a43/ca1dc/TC_15.png 680w,\n/blog/static/472968973302d625118374f1b31f9a43/02d09/TC_15.png 1020w,\n/blog/static/472968973302d625118374f1b31f9a43/f7f62/TC_15.png 1096w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>느린 시작 임계치 넘음 -&gt; 혼잡 회피</figcaption>\n  </figure>\n혼잡 회피 도중 타임아웃이 발생하면 혼잡 윈도우 값은 1로, 느린 시작 임계치는 혼잡이 감지된 시점의 혼잡 윈도우 값의 절반으로 초기환 한 뒤 다시 느린 시작을 수행한다. 그리고 혼잡 회피 도중 세 번의 중복 ACK 세그먼트가 발생되었을 때는 혼잡 윈도우 값과 느린 시작 임계치를 대략 절반으로 떨어뜨린 뒤 빠른 알고리즘을 수행한다. </p>\n<h3 id=\"빠른-회복-알고리즘\" style=\"position:relative;\"><a href=\"#%EB%B9%A0%EB%A5%B8-%ED%9A%8C%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"빠른 회복 알고리즘 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>빠른 회복 알고리즘</h3>\n<p>빠른 회복 알고리즘은 세 번의 중복 ACK 세그먼트를 수신했을 때 느린 시작은 건너뛰고 혼잡 회피를 수행하는 알고리즘으로, 빠르게 전송률을 회복하기 위한 알고리즘이다.</p>\n<p>세 번의 중복된 ACK 세그먼트를 수신하면 빠른 재전송 후 빠른 회복 알고리즘이 수행된다. 단, 빠른 회복 도중이라도 타임아웃이 발생하면 혼잡 윈도우 크기는 1로, 느린 시작 임계치는 혼잡이 감지된 시점의 절반으로 떨어뜨린 후 다시 느린 시작을 수행한다.</p>\n<p>아래 그림은 지금까지의 혼잡 알고리즘을 정리한 그림이다.\n<span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/blog/static/2c7811ecd76d6121c2940017157a73ea/5d041/TC_16.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 47.05882352941176%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABQElEQVR42m1Qi3KCMBDk/3+slToCM2VApLXWF2DVoCCgwDZ7FVqrmdlJbrO3t4nRti3iOEZRFOBi3aGruZqmQV3XN/f/wXujbRttmNwZ1trgdDqJqCxLKKVQnc+4iu6G94YyvW5wFvFvMl7GUYztdivGl8tFUtI8yzJUVXWXWAyrSguORxGQZBPBJhrx3D2Zpkrt5YuOuod1F6ALYaSpwmq1FAMKmLQsSuRZ3v9bxx8OB+R53qchz8Uw/DLqjc1mg/l8Lk9L0xRKY7/bSfMjcDBBLXuSJMGX9mBi8mJIrNdrfEynCCcTrJZLedYjRFEkO/Wfsxmmb+/CEYvFAkYYhiCCIMDY938wHt8g0EN8zXueJ2dqefZeXQRXja9r13Vh2LaNHo4Nx3Hwl7NGI5hPz4IXwUC4oWliODB7PXfLsvANpSepyj97g9IAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='TC 16' title='' src='/blog/static/2c7811ecd76d6121c2940017157a73ea/ca1dc/TC_16.png' srcset='/blog/static/2c7811ecd76d6121c2940017157a73ea/e7570/TC_16.png 170w,\n/blog/static/2c7811ecd76d6121c2940017157a73ea/f46e7/TC_16.png 340w,\n/blog/static/2c7811ecd76d6121c2940017157a73ea/ca1dc/TC_16.png 680w,\n/blog/static/2c7811ecd76d6121c2940017157a73ea/02d09/TC_16.png 1020w,\n/blog/static/2c7811ecd76d6121c2940017157a73ea/9d567/TC_16.png 1360w,\n/blog/static/2c7811ecd76d6121c2940017157a73ea/5d041/TC_16.png 1988w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>","frontmatter":{"title":"TCP의 오류・흐름・혼잡 제어","date":"May 21, 2025","update":"May 21, 2025","tags":["Network","TCP","전송계층"],"series":"혼자 공부하는 네트워크"},"fields":{"slug":"/TCPControl/","readingTime":{"minutes":14.465}}},"seriesList":{"edges":[{"node":{"id":"d7e4a629-d0cf-5fe1-ba70-9248990d30d3","fields":{"slug":"/StartNetwork/"},"frontmatter":{"title":"컴퓨터 네트워크 찍어먹기"}}},{"node":{"id":"73ae3d31-a3bf-5caf-a54f-185a7c3504a0","fields":{"slug":"/Ethernet/"},"frontmatter":{"title":"이더넷은 무엇인가"}}},{"node":{"id":"7e3487fc-8bf9-5b41-97a9-0f1b6af48b2b","fields":{"slug":"/NICAndCable/"},"frontmatter":{"title":"NIC와 케이블"}}},{"node":{"id":"7d6b51b9-570b-5dbc-86ae-1cf397dcbdb3","fields":{"slug":"/NetworkHub/"},"frontmatter":{"title":"허브"}}},{"node":{"id":"1f35b10b-2265-5c7d-94ad-fb2899a9866d","fields":{"slug":"/NetworkSwitch/"},"frontmatter":{"title":"스위치 (딸깍)"}}},{"node":{"id":"c3df0ad3-6d55-5281-b0a2-fba7c306a3a6","fields":{"slug":"/NetworkLayer/"},"frontmatter":{"title":"LAN을 넘어서는 네트워크 계층"}}},{"node":{"id":"1dc64a67-75d2-5b8f-a8d3-1811d8c49993","fields":{"slug":"/NetworkIPAddress/"},"frontmatter":{"title":"IP 주소"}}},{"node":{"id":"d00163a5-202b-5072-ac15-7daf2ecfe528","fields":{"slug":"/NetworkRouting/"},"frontmatter":{"title":"라우팅"}}},{"node":{"id":"d96a9462-f669-5fa5-850d-3f87327212ba","fields":{"slug":"/LimitOfIpAndAboutPort/"},"frontmatter":{"title":"IP의 한계와 포트"}}},{"node":{"id":"4b022313-cdc3-5705-98c7-a7a55fb066d7","fields":{"slug":"/PortNAT/"},"frontmatter":{"title":"포트 기반 NAT"}}},{"node":{"id":"601af995-41a7-5b33-baf4-fbc7b350881f","fields":{"slug":"/PortForwarding/"},"frontmatter":{"title":"포트포워딩"}}},{"node":{"id":"ed3bbb64-b393-5247-84ff-8d8c5df7a7d8","fields":{"slug":"/ICMP/"},"frontmatter":{"title":"ICMP"}}},{"node":{"id":"20d44432-46fa-5c98-91ff-170f0579a6ca","fields":{"slug":"/TCPAndUDP/"},"frontmatter":{"title":"TCP와 UDP"}}},{"node":{"id":"9efc28d3-1946-58e8-a2a3-2de57b179d47","fields":{"slug":"/TCPControl/"},"frontmatter":{"title":"TCP의 오류・흐름・혼잡 제어"}}},{"node":{"id":"602e5618-4b79-53ff-81db-4aacd496a9ea","fields":{"slug":"/DNS/"},"frontmatter":{"title":"DNS와 자원"}}},{"node":{"id":"2a7d2fde-d96b-597b-a234-ef44d404f4df","fields":{"slug":"/HTTP/"},"frontmatter":{"title":"HTTP"}}},{"node":{"id":"8ce3c921-40a8-5c1f-a269-c9a743a4ec3e","fields":{"slug":"/StabilitySkill/"},"frontmatter":{"title":"네트워크의 안정성을 위한 기술"}}},{"node":{"id":"e825178a-1e4e-5cfb-9850-d97808262d7e","fields":{"slug":"/HTTPHeader/"},"frontmatter":{"title":"HTTP 헤더"}}},{"node":{"id":"10454511-fcbb-5293-a402-3cd49b01efd7","fields":{"slug":"/HTTPCache/"},"frontmatter":{"title":"HTTP 캐시"}}},{"node":{"id":"42ea408a-aa21-587a-99ea-5d3091998d2c","fields":{"slug":"/HTTPCookie/"},"frontmatter":{"title":"HTTP 쿠키"}}}]},"previous":{"fields":{"slug":"/TCPAndUDP/"},"frontmatter":{"title":"TCP와 UDP"}},"next":{"fields":{"slug":"/DNS/"},"frontmatter":{"title":"DNS와 자원"}}},"pageContext":{"id":"9efc28d3-1946-58e8-a2a3-2de57b179d47","series":"혼자 공부하는 네트워크","previousPostId":"20d44432-46fa-5c98-91ff-170f0579a6ca","nextPostId":"602e5618-4b79-53ff-81db-4aacd496a9ea"}},"staticQueryHashes":[],"slicesMap":{}}