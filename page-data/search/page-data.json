{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"복약기록 서비스인 Flow를 개발하던 중, 처방전의 내용을 바탕으로 복약할 약을 자동으로 추가할 수 있는 기능 개발을 진행하려고 하였다. 1. 처방전의 글자를 인식하는 방법 1-1. 처방전의 형태 분석 먼저 처방전의 형태가 어떤식으로 생겼는지 조사를 시작하였다.\n\n질병관리청 국가건강정보포털의 처방전과 약 설명서 읽는 방법! 알려드리겠습니다!에 따르면, 처…","fields":{"slug":"/MakePrescriptionOCR/"},"frontmatter":{"date":"November 04, 2025","title":"iOS에서 처방전 약 이름 추출하기","tags":["OCR","iOS-Vision","iOS"]},"rawMarkdownBody":"복약기록 서비스인 Flow를 개발하던 중, 처방전의 내용을 바탕으로 복약할 약을 자동으로 추가할 수 있는 기능 개발을 진행하려고 하였다.\n\n## 1. 처방전의 글자를 인식하는 방법\n### 1-1. 처방전의 형태 분석\n먼저 처방전의 형태가 어떤식으로 생겼는지 조사를 시작하였다.\n![출처: 질병관리청 국가건강정보포털](o-1.png)\n질병관리청 국가건강정보포털의 [처방전과 약 설명서 읽는 방법! 알려드리겠습니다!](https://health.kdca.go.kr/healthinfo/biz/health/gnrlzHealthInfo/gnrlzHealthInfo/gnrlzHealthInfoView.do?cntnts_sn=3607)에 따르면, 처방전에는 크게 **약국제출용**과 **환자보관용**이 있으며, 위 사진과 같은 구성으로 이루어져 있다고 한다.\n\n1. 약국제출용, 환자보관용 식별 글자\n2. 대상 환자의 정보 (성명, 주민등록번호)\n3. 환자가 가진 질병에 따른 질병분류기호\n4. 환자가 처방받은 의약품 이름\n5. 약의 적정 투여량, 투여횟수, 투약알수\n6. 약을 먹는 방법(용법)\n7. 처방전의 사용 기간\n\n여기서 내가 필요한 정보는 **4번째의 처방받은 의약품 이름**이다.\n\n### 1-2 처방전에서 약 이름 추출\n사진에 글자를 추출하는 방식은 크기 2가지를 찾을 수 있었다.\n1. 광학 문자 인식(OCR)\n2. AI 기반 텍스트 추출\n\n두 방법의 장단점은 아래와 같다.\n\n| 항목       | OCR 방식                  | AI 기반 방식                         |\n| -------- | ----------------------- | -------------------------------- |\n| 인식 정확도   | 사진 품질에 따라 다르나, 일반적으로 낮음 | 높음 (저해상도나 복잡한 레이아웃도 인식 가능)       |\n| 전처리 의존도  | 매우 높음                   | 비교적 낮음                           |\n| 속도       | 빠름 (가벼워서 로컬에서도 처리 가능)   | 비교적 느림 (모델에 따라 다르나 일반적으로 연산량이 큼) |\n| 온디바이스 실행 | 가능                      | 어려움 (외부 모델서버에 의존)                |\n| 비용       | 무료                      | 유료 (외부 API 사용해야함)                |\n\n이 둘을 비교했을 때, 비교적 인식 정확도는 낮지만 비용과 속도 그리고 온디바이스 실행이 가능한 OCR 기능을 사용하는 것이 합리적이라 생각하여 iOS에서 OCR은 어떤식으로 구현해야 하는지 찾아보았다.\n\niOS에서는 [VisionKit](https://developer.apple.com/documentation/visionkit)이라는 apple의 자체 API로 OCR을 지원한다는 문서를 찾을 수 있었다. 심지어 iOS 16.4 이상부터는 한국어까지 지원하기 때문에 안쓸 이유가 없었다.\n\n## 2. VisionKit으로 처방전 약품명 추출하기\n### 2-1. AVFoundation으로 카메라 기능 구현하기\n먼저 VisionKit에서 인식할 사진을 찍는 기능을 구현하기 위해 AVFoundation으로 카메라 기능을 구현하였다. \n\n[AVFoundation](https://developer.apple.com/documentation/avfoundation)은 Apple 플렛폼 시청각 매체의 검사, 재생, 캡처 및 처리 과정에 필요한 작업들을 모아둔 라이브러리이다. 해당 라이브러리의 [AVCaptureDevice](https://developer.apple.com/documentation/avfoundation/avcapturedevice/), [AVCaptureSession](https://developer.apple.com/documentation/avfoundation/avcapturesession/), [AVCaptureVideoPreviewLayer](https://developer.apple.com/documentation/avfoundation/avcapturevideopreviewlayer/) 등의 클래스를 활용하면 커스텀 카메라 화면을 구현할 수 있다.\n\n자세한 구현은 [해당 블로그](https://velog.io/@heyksw/iOS-AVFoundation-%EC%9C%BC%EB%A1%9C-custom-camera-%EA%B5%AC%ED%98%84)를 참고하였다.\n\n아래와 같은 UI로 사용자가 처방전의 의약품 명칭 부분을 촬영할 수 있도록 구현하였다.\n![](o-2.png)\n\n### 2-2. 촬영한 사진 VisionKit으로 글자 추출하기\n촬영한 사진의 글자를 VisionKit으로 분석하기 위해서는 `VNImageRequestHandler`이라는 클래스와 `VNRecognizeTextRequest`이라는 클래스를 사용해야 한다. \n\n`VNImageRequestHandler`은 단일 이미지에 대해 하나 이상의 분석 요청을 하기위한 객체로, 생성자로 `cgImage`를 받는다.\n\n``` swift\nlet handler = VNImageRequestHandler(cgImage: cgImage)\n```\n\n`VNRecognizeTextRequest`은 이미지에서 텍스트를 찾는 요청을 하기위한 객체로, 해당 객체를 사용해서 위에서 설정한 `VNRecognizeTextRequest` 이미지의 텍스트 분석 요청을 진행할 수 있다. 클로저를 사용하여 분석 결과를 반환하는데, 분석된 텍스트의 위치(CGRect)와 분석 텍스트를 받을 수 있다.\n\n`VNRecognizeTextRequest`의 초기 설정으로 어떤 버전의 비전을 사용할건지, 어떤 언어를 분석할 것 인지 등을 설정할 수 있다. 자세한 내용은 [공식문서](https://developer.apple.com/documentation/vision/vnrecognizetextrequest)를 참고하였다.\n``` swift\nlet request = VNRecognizeTextRequest { [weak self] request, error in\n\n\tguard let observations = request.results as? [VNRecognizedTextObservation],\n\t\terror == nil else { return }\n\n\tlet texts = observations.compactMap { $0.topCandidates(1).first?.string }\n\n\t// OCR 결과물\n\tprint(texts)\n}\n\n// 버전 설정\nrequest.revision = VNRecognizeTextRequestRevision3\n// 인식 레벨 설정\nrequest.recognitionLevel = .accurate\n// 언어 설정\nrequest.recognitionLanguages = [\"ko-KR\", \"en-US\"]\n// 언어 교정 사용여부\nrequest.usesLanguageCorrection = true\n```\n\n이제 `VNImageRequestHandler` 객체의 `preform(_:)`을 사용해서 이미지 분석 요청을 진행해 준다.\n``` swift\ntry? handler.perform([request])\n```\n\n### 2-3. 전처리 진행\nOCR진행 후 결과물을 살펴보면, `646201050 (급) 파모시드정 20mg`이나 `처방 의약품 명칭`과 같이 약품명과 관련 없는 문장들이 포함되어 있는 것을 볼 수 있다. 그래서 아래와 같은 4단계의 작업을 통해 가능한 순수한 약품명을 얻을 수 있도록 구현하였다.\n#### 1. 필요없는 문장 제거\n`주사제 처방내역`, `~습니다`, `~합니다`, `~마세요` 와 같은 약품명과 관계없는 단어들을 선정하여 배열에 저장한 후, 해당 단어가 포함되어 있는 값 제외\n``` swift\nlet unAbleString = [\"•\", \"합니다\", \"습니다\", \"마세요\", \"계산서\", \"영수증\", \"공제신청\", \"세부내역\", \"부담항목\", \"복용\", \"봉투\", \"처방\", \"처방의약품\", \"명칭\", \"환자\", \"질병\" ,\"투여\", \"투약\", \"구분코드\", \"봉투\", \"약품\", \"값\", \"횟수\", \"일수\", \"총투\", \"여백\"]\n\n// 필요없는 문장 필터링 진행\nlet longStringFilterTexts = texts\n\t.filter { text in\n\t\tunAbleString.contains { word in text.contains(word) } == false\n\t}\n```\n#### 2. 공백 기준으로 문장 분리\n`646201050 (급) 파모시드정 20mg`과 같은 문장에서 약품명을 분리하기 위해 공백 기준으로 문장 분리\n``` swift\n// 공백 기준으로 문장 분리\nlet spliteTexts = longStringFilterTexts\n\t.flatMap { \n\t\t$0.components(separatedBy: .whitespaces)\n\t\t\t.filter { $0.isEmpty == false }\n\t}\n```\n#### 3. 약품명의 기본 조건을 만족하지 않는 단어 제외\n단어 개수가 1개 이하, 단어가 숫자로만 구성, 단어 첫 문자가 숫자인 단어 제외\n``` swift\nlet filterTexts = spliteTexts\n\t// 문장 개수가 1개 이하 제거\n\t.filter { $0.count > 1 }\n\t// 숫자로만 이루어저 있는 문장 제거\n\t.filter { $0.allSatisfy { $0.isNumber } == false }\n\t// 첫 단어가 숫자인 문장 제거\n\t.filter { $0.first!.isNumber == false }\n```\n#### 4. 특수문자가 들어간 단어 제외 및 단위 제거\n괄호나 덧셈기호 같은 특수문자가 들어간 단어 제외, `파모시드정20mg`에서 `20mg` 같은 단위 제거\n``` swift\nlet unAbleCharacters = [\"(\", \")\", \"[\", \"]\", \",\", \"-\", \"+\", \"\\\\\", \"|\"]\n\n// 특수문자 필터링 진행 및 단위 삭제\nlet validTexts = filterTexts\n\t.filter { text in\n\t\tunAbleCharacters.contains { word in text.contains(word) } == false\n\t}\n\t.map { text in\n\t\tif let index = text.firstIndex(where: { $0.isNumber }) {\n\t\t\treturn String(text[..<index])\n\t\t} else {\n\t\t\treturn text\n\t\t}\n\t}\n\t.filter { $0.count > 1 }\n```\n### 전처리 결과물\n![전처리 진행 사진](o-3.png)\n![전처리 전/후 비교 사진](o-4.png)\n### 2-4. 촬영 가이드라인 구현\n좋은 품질의 결과물을 얻으려면 전처리도 중요하지만, 무엇보다 효과적인 방법은 사용자에게 정확한 촬영 방법을 가이드라인으로 안내하는 것이다. 이를 위해 촬영 전 가이드라인 페이지를 노출시켜 사용자가 올바른 촬영을 진행하도록 유도하였다.\n![촬영 가이드라인 화면](o-5.png)\n(여담으로 처방전 사진은 저작권 등의 문제를 피하기 위해 한땀한땀 피그마로 제작하였다...)\n## 3. 추출한 약품명을 사용해 약 검색하기\n추출한 약품명을 식약처 API를 사용해 실제 존재하는 약인지 검증하는 과정을 거쳤다. 만일, 여기서 결과값이 나오지 않는다면 사용자에게 재촬영을 요청하도록 구현하였다.\n![약의 이름을 찾을 수 없을 때 화면](o-6.png)![약 검색에 성공하였을 때 화면](o-7.png)\n만일 약 검색에 성공했다면, 해당 결과중 원하는 약을 사용자가 선택하여 추가할 수 있도록 구현하였다.\n\n좀더 자세한 작동 과정을 보고 싶다면? 아래 링크 참고 (홍보 맞다 ㅎㅎ)\nhttps://apps.apple.com/us/app/flow-%EB%A7%A4%EC%9D%BC-%EB%B3%B5%EC%9A%A9%ED%95%9C-%EC%95%BD-%EA%B8%B0%EB%A1%9D%ED%95%98%EA%B8%B0/id6502969163\n\n## 참고\n- https://ohwhatisthis.tistory.com/17\n- https://developer.apple.com/documentation/visionkit\n- https://zeddios.tistory.com/526\n- https://velog.io/@heyksw/iOS-AVFoundation-%EC%9C%BC%EB%A1%9C-custom-camera-%EA%B5%AC%ED%98%84\n- https://developer.apple.com/documentation/avkit\n- https://developer.apple.com/documentation/avfoundation"},{"excerpt":"값 타입과 참조 타입 Swift의 값에는 값 타입과 참조 타입이라는 종류가 있다. 흔히 Class와 Struct의 차이점이 무엇인지 대답할때 사용하곤 하는데, 정확한 뜻은 아래와 같다.  참조 타입 값 타입 의미 데이터를 전달할 때 값의 메모리 위치를 전달 데이터를 전달할 때 값을 복사하여 전달 예시 Class, Closures Struct, Enum, …","fields":{"slug":"/ArrayInSwift/"},"frontmatter":{"date":"October 14, 2025","title":"Swift에서 Array를 관리하는 방법","tags":["Copy-On-Write","Swift"]},"rawMarkdownBody":"## 값 타입과 참조 타입\nSwift의 값에는 값 타입과 참조 타입이라는 종류가 있다. 흔히 Class와 Struct의 차이점이 무엇인지 대답할때 사용하곤 하는데, 정확한 뜻은 아래와 같다.\n\n|           | 참조 타입                    | 값 타입                                          |\n| --------- | ------------------------ | --------------------------------------------- |\n| 의미        | 데이터를 전달할 때 값의 메모리 위치를 전달 | 데이터를 전달할 때 값을 복사하여 전달                         |\n| 예시        | Class, Closures          | Struct, Enum, Int, String, Array, Set 등 기본 타입 |\n| 메모리 저장 위치 | 힙(Heap) 메모리              | 스택(Stack) 메모리                                 |\n여기서 메모리에 대해 조금 공부해본 경우, 힙 메모리에는 **동적인 데이터**가 들어가고 스택 메모리에는 **정적인 데이터**가 들어갈 수 있다는 것을 알 수 있는데, Swift에서는 이상하게 Array나 Set 같은 동적으로 관리해야 하는 자료형도 값 타입으로 분류되어 스택 메모리에 저장된다는 모순점을 찾을 수 있다. \n\n왜 그럴까?\n## Array는 사실 힙 메모리에 저장된다\nSwift에서 Array는 값 타입이지만 힙 메모리와 스택 메모리를 둘다 사용한다.\n\n정확하게는,\n\nArray의 **메타데이터(길이, 용량, 참조 포인터 등..)는 스택 메모리에 저장**되고,<br>**실제 원소들([1, 2, 3 ...])은 힙 메모리**에 저장된다.\n\n이런 방식을 사용해서 Swift의 Array를 비롯한 컬렉션 타입(Collection Types)은 값 타입의 특성을 지니면서 동적인 크기를 가진 자료형이 될 수 있던 것이다.\n\n## COW(Copy-On-Write) 전략\nCOW 전략은 Swift의 값 타입 메모리를 효율적으로 사용할 수 있는 기법이다.\n\n값 타입은 값을 복사하여 데이터를 전달하기 때문에 만약 복사해야 할 값이 매우 큰 사이즈라면 복사하는 작업 만으로도 많은 리소스를 필요로 할 것이다. 그리고 만약 값을 복사했는데 사용하지 않는다면 이는 큰 자원 손실로 이어질 것이다.\n\n이런 문제를 해결하기 위해 Swift에서는 **값의 변경이 일어나는 시점에서 복사를 진행**하는 방법을 사용한다. 이름 그대로 쓰기(Write)를 할 때 복사(Copy)하는 전략인 것이다.\n\nArray, Set, Dictionary와 같은 컬렉션 타입들은 모두 COW를 사용해 메모리를 효율적으로 관리하고 있는 것이다."},{"excerpt":"DNS에 관련된 내용은 여기에.. DNS 레코드와 종류 DNS Record는 DNS 서버가 도메인에 연계된 IP주소 및 해당 도메인에 대한 요청의 처리 방법에 대한 정보를 제공하는 명령이다. DNS 레코드에는 각 레코드의 목적에 맞는 여러 종류들이 있다. DNS 레코드의 TTL DNS 레코드를 설정할 때, TTL이라는 값을 확인할 수 있는데, 이는 tim…","fields":{"slug":"/DNSRecord/"},"frontmatter":{"date":"September 05, 2025","title":"DNS 레코드","tags":["DNS","DNS-Record"]},"rawMarkdownBody":"DNS에 관련된 내용은 [여기](https://bjcho0501.github.io/blog/DNS/)에..\n\n## DNS 레코드와 종류\nDNS Record는 DNS 서버가 도메인에 연계된 IP주소 및 해당 도메인에 대한 요청의 **처리 방법에 대한 정보**를 제공하는 **명령**이다. DNS 레코드에는 각 레코드의 목적에 맞는 여러 종류들이 있다.\n\n> **DNS 레코드의 TTL**\n> \n> DNS 레코드를 설정할 때, TTL이라는 값을 확인할 수 있는데, 이는 time-to-live의 약자로 DNS 서버가 해당 헤코드를 새로 고치는 빈도를 나타낸다.\n\n### A 레코드\n**도메인 주소와 서버의 IP주소**를 직접 매핑시키는 방법이다. (도메인 - IP 간 연결)\n\n일대다 / 다대일 매핑이 가능하다.\n### CNAME (Canonical Name Record)\n**도메인 별명 레코드**라고 부르며, 도메인 주소를 또 다른 도메인 주소로 이중 매핑 시키는 방법이다. (도메인 - 도메인 간 연결)\n\n무조건 다른 도메인 주소를 등록해야 하며 A 레코드처럼 직접 IP주소를 등록할 수 없다.\n### AAAA 레코드\nA레코드의 IPv6 버전이다. A와 마찬가지로 도메인 - IP간을 매핑하는 레코드이다.\n### MX (Mail Exchanger)\n**메일 서버 레코드**로, 해당 도메인과 연동되어있는 메일서버를 확인하는데 사용하는 레코드이다.\n만일 도메인을 이메일 주소로 사용하고 싶다면, MX 레코드를 설정해야 한다는 것이다.\n\nMX 레코드는 일반적으로 도메인을 구입한 회사 홈페이지에서 설정할 수 있다.\n### NS (Name Server)\n도메인에 대한 **네임서버의 권한을 누가 관리하가 있는지** 알려주는 레코드이다. 도메인에 대한 처리를 다른 도메인 네임 서버(도메인을 관리하는 서버)에게 위임하기 위해 사용한다.\n\n예를들어, `hello.kr`이라는 도메인을 cafe24 업체에서 구입해 사용하고 있다면, `hello.kr` 도메인을 관리하는 네임 서버는 cafe24가 되는 것이다.\n### PTR (Pointer)\n**IP 주소에 대한 도메인 주소를 확인**할 수 있는 레코드이다. (A 레코드의 반대 방향, IP - 도메인 간 연결)\n\nA레코드와 달리 **1개의 IP에 1개의 도메인 네임**만 가질 수 있다.\n### SOA (Start of Authority)\n네임서버가 해당 도메인에 관하여 **인증된 데이터를 가지고 있음**을 증명하는 레코드이다. DNA 영역에 대한 핵심 정보를 지정하며, SOA레코드가 없는 도메인은 네임서버에서 정상적으로 동작하지 않게 된다.\n\nSOA 레코드는 아래와 같은 구성으로 이루어져있다.\n1. `Mname / primary name`: 도메인에 대한 기본 호스트네임\n2. `Rname / mail addr`: 관리자의 이메일 주소이며, @대신 마침표(.)가 들어가 있다.\n3. `serial`: 도메인의 갱신 버전 번호. 일반적으로 날짜(YYYYMMDD)형식\n4. `refresh`: 도메인 영역의 데이터 갱신 여부를 체크하는 주기 (초단위)\n5. `retry`: retry의 주기로 체크를 반복하다가, 도메인을 더 이상 신뢰할 수 없는 영역이라고 간주하고 서비스를 중단하는 최대 기한\n6. `minimum`: 도메인을 찾을 수 없는 경우, 네임 서버가 도메인의 부재정보를 캐싱하는 시간\n### TXT (Text)\n텍스트를 입력할 수 있는 레코드이며, 주로 **메모를 남기는 용도**이다.\n\n여담으로 Google Search Console에서는 도메인의 주인임을 인증하기 위해 TXT 레코드에 식별문자를 넣는 방식을 사용한다.\n### SPF (Sender Policy Framework)\n특정 도메인에서 이메일을 보낼 수 있도록 **메일 수신을 승인할 모든 주소를 명시**하는 이메일 인증 역할을 한다.\n\nSPF 레코드를 등록하게 되면, 메일을 받는 서버는 보낸 메일 주소로부터 취득한 도메인 정보로 그 DNS 레코드를 SPF 레코드의 값과 비교하여 원본 주소를 위장한 스팸 메일이 아닌지 여부를 판단할 수 있게 된다.\n\n지금은 공식적으로 지원을 중단하여 **SPF레코드를 설정하려면 TXT레코드에서 설정**해야 한다.\n### CAA (Certificat Authority Authorization)\n도메인 인증 기간에 관련된 레코드이다.\n### HINFO (Host Information)\n**호스트에 대한 일반 정보**를 얻는데 사용되는 레코드이다. CPU 및 OS의 유형을 얻을 수 있지만, 일반적으로 보안상의 이유 때문에 공용 서버에서 사용되지 않는 편이다.\n### ISDN (Integrated Services Digital Network)\nISDN 주소를 알려주는 레코드이다.\n\nISDN 주소란, 국가 코드, 국가 별 대상 코드, ISDN 가입자 번호 및 선택적으로 ISDN 하위 주소로 구성된 전화번호이다."},{"excerpt":"개발 환경 Next.js   react  vercel 배포 문제 상황 Notion API를 사용하여 웹 프로젝트를 만들던 중, 아래와 같이 사진 파일이 보이지 않는 문제가 발생하였다. \n 또, Vercel의 이미지 캐싱 쓰기 횟수가 이미지 양에 비해 상당히 높은 문제도 발생하였다.\n 원인 노션 API를 사용하여 특정 데이터베이스의 파일 정보를 가져오게 된…","fields":{"slug":"/NotionApiImageUrl/"},"frontmatter":{"date":"August 29, 2025","title":"Notion API의 이미지를 만료기간 없이 사용하고 성능 개선하기","tags":["Notion-API"]},"rawMarkdownBody":"> ### 개발 환경\n> - Next.js  `v15.4.6`\n> - react `v19.1.0`\n> - vercel 배포\n\n## 문제 상황\nNotion API를 사용하여 웹 프로젝트를 만들던 중, 아래와 같이 사진 파일이 보이지 않는 문제가 발생하였다. \n![](n-1.png)\n\n또, Vercel의 이미지 캐싱 쓰기 횟수가 이미지 양에 비해 상당히 높은 문제도 발생하였다.\n![](n-3.png)\n## 원인\n노션 API를 사용하여 특정 데이터베이스의 파일 정보를 가져오게 된다면 아래와 같은 URL형식으로 받을 수 있게 된다.\n``` json\n// 노션 API의 응답 중 이미지 url에 관련된 일부분\n\n//...\n{\n\t\"name\": \"IMG_0750.JPG\",\n\t\"type\": \"file\",\n\t\"file\": {\n\t\t\"url\": \"https://prod-files-secure.s3.us-west-2.amazonaws.com/c82cac33-9f75-811d-b353-0003cf829c63/b916f417-f8b3-4fc7-bf3f-76c04abd7716/IMG_0750.jpg?...\",\n\t\t\"expiry_time\": \"2025-08-28T09:29:09.038Z\"\n\t}\n},\n//...\n```\n\njson을 살펴보면 알 수 있듯이 파일 url에 만료 기간이 정해저 있기 때문에 만료기간 이후 url을 갱신할 필요가 있다. 또, 매번 url이 달라지기 때문에 같은 이미지라 해도 vercel에서는 다른 이미지로 인식하기 때문에 매번 캐시에 이미지를 저장하는 문제가 발생한다.\n\n> url을 보면 `X-Amz-Expires`이라는 값을 확인할 수 있는데 이는 AWS에서 재공하는 pre-signed URL에 유효 기간을 초단위로 나타내는 파라미터이다. [자세한 내용](https://aws.amazon.com/ko/blogs/korea/aws-api-call-2-s3-pre-signed-url/)\n\n\n## 시도1. fetch에 revalidate 설정 (실패)\nnext.js의 fetch에는 revalidate라는 옵션을 설정해서 특정 시간마다 저장해둔 캐시 데이터를 갱신 시키도록 할 수 있다. revalidate를 1시간(3600초) 보다 빠르게 설정한다면 파일 url이 만료되기 전 새로운 url을 갱신하게 되어 이미지가 보이지 않는 문제를 해결할 수 있을 것이다. [공식 문서](https://nextjs.org/docs/app/getting-started/caching-and-revalidating#unstable_cache)\n\n### 실패) 갱신된 이미지 만료 후 사이트 진입시 여전히 이미지가 보이지 않음\n만료되지 않은 이미지가 캐싱되고 1시간 이상 지난 뒤에 다시 사이트에 진입하기 되면, 여전히 캐싱된 이미지(이미 만료된 이미지)를 보여줌.\n\n수동으로 재로딩(`Cmd + R`)을 하면 갱신이 되지만, 해당 방법으로는 Vercel에서 이미지 캐시 낭비 문제를 해결할 수 없기 때문에 다른 방법이 필요함.\n\n## 시도2. Notion 페이지 게시를 활용한 정적 이미지 URL 사용 (성공)\n노션 API로 불러오는 페이지를 게시하기 되면 해당 페이지의 게시 URL이 생기게 되는데, 이 URL을 통해 정적인 사진 URL을 얻을 수 있어 이미지가 보이지 않는 문제와 캐싱 문제를 해결할 수 있을 것이다.\n\n### 게시된 사이트의 이미지 URL 분석\n![게시한 사이트의 이미지 URL](n-4.png)\n먼저 노션으로 게시한 사이트에 들어가 개발자 모드로 사진의 URL 원문을 가져와 분석해 보았다. \n\n#### a. 메인 URL과 /image/attachment\n```text\nhttps://{노션 페이지 메인 URL}/image/attachment...\n```\n앞쪽의 메인 URL은 노션에서 페이지를 게시할 때 주어지는 메인 URL과 동일했다. 이후`/image/attachment`라고 붙는 것까지 알 수 있다.\n\n#### b. attachment와 연결되어 있는 부분\n```text\nattachment%3Ae8c63e9b-e829-4dc5-852c-ba11b43ca491%3A01.jpg\n```\n%으로 시작되는 부분부터 jpg로 끝나는 부분 중 유추 가능한 점은 jpg로 끝나는 끝부분에 사진의 이름과 확장자가 붙어 있다는 것이다. 해당 사진의 원본 이름은 `01.jpg`이기 때문에 나머지 부분이 해당 사진의 특정 식별자 라는 것을 유추할 수 있다.\n\n`%3Ae8c63e9b-e829-4dc5-852c-ba11b43ca491%3A`이라는 문자열을 URL Decoder로 디코딩 하게 되면 `:e8c63e9b-e829-4dc5-852c-ba11b43ca491:`이라는 결과를 얻게 되며 `%3A`라는 값이 `:`을 URL로 인코딩한 값이라는 것을 알게 된다. \n\n위 값에서 나온 `e8c63e9b-e829-4dc5-852c-ba11b43ca491`이라는 값을 노션 API의 응답 json에서 찾아본결과 file URL에 포함되어 있는 값이라는 것을 알 수 있었다.\n![Postman을 사용하여 값을 확인한 화면](n-5.png)\n#### c. queryString의 id 부분\n해당 부분은 따로 인코딩된 부분이 없기 때문에 바로 노션 API의 응답에서 찾아 보았다. 확인 결과 노션 API에서 가져올 수 있는 id 값이였다.\n![특정 페이지의 id 값을 의미한다는 것을 확인할 수 있다](n-6.png)\n#### d. 필요하지 않는 값 (spaceid, userid)\nspaceid와 useid값의 경우 값을 추가하지 않아도 사진 데이터를 불러오는데 문제가 없었기 때문에 추가하지 않기로 하였다.\n#### e. 나머지 고정값 (table, cache, width)\ntable과 cache값의 경우 모든 사진 URL에서 고정으로 동일한 값이 들어가기 때문에 해당 값을 그대로 추가하였다. width값은 1000정도로 사용하기로 하였다.\n- table: block\n- cache: v2\n- width: 1000\n\n최종적으로 분석한 값들을 조합하면 다음과 같다.\n```\nhttps://{노션 페이지 메인 URL}/image/attachment%3A{노션 API의 url에 포함된 고유 id}%3A{파일 원본 이름}?id={노션 api의 특정 페이지 id}&width=1000&table=block&cache=v2\n```\n\n### 노션 api URL을 게시 페이지 이미지 URL로 변환\n분석한 규칙을 바탕으로 게시 페이지 이미지 URL 반환 함수를 작성해 준다.\n```js\nfunction notionFileUrlGenerator(originUrl: string, resultID: string): string {\n\t// 원본 URL에서 필요한 부분만 추출\n\tconst [, , imageId, imageName] = originUrl.split(\"//\")[1].split(\"?\")[0].split(\"/\");\n\t\n\t// 게시 페이지의 정적 URL로 가공\n\tconst resultUrl = `${process.env.NOTION_PAGE_URL}/image/attachment${encodeURIComponent(`:${imageId}:`)}${imageName}?id=${resultID}&width=1000&table=block&cache=v2`;\n\t\n\treturn resultUrl;\n}\n```\n해당 함수를 DTO to Entity mapper 함수에서 사용하여 노션 API의 만료 기간이 있는 이미지 URL을 게시 페이지의 정적 URL로 변환 후 사용하도록 한다.\n\n## 결과\n![정상적으로 이미지가 뜨는 모습](n-7.png)\n이미지의 만료 기간이 없기 때문에 언제든 사진이 잘 나온다.\n\n![26,909 -> 5,906으로 이미지 캐시 쓰기가 줄어든 모습](n-8.png)\n또한, 이미지 캐시 쓰기의 횟수가 26,909번에서 5,906번으로 약 **78.1%** 개선된 것을 확인할 수 있다.\n### + 한달 후 결과 (2025.09.25)\n![Image Cache Writes 1달 후 지표](n-10.png)\n### 참고자료\n- https://velog.io/@soooee/%EB%85%B8%EC%85%98-API-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%82%AC%EC%9A%A9-%EC%8B%9C-URL-%EB%A7%8C%EB%A3%8C-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0\n- https://weezip.treefeely.com/post/weezip-use-notion-image"},{"excerpt":"낙관적인 개발이란? \n사전상 낙관은 \"미래를 밝고 희망적으로 보는 것\" 이라고 정의한다. 이런 의미를 개발에 접목하여 해석하면 \"어떤 공정(task)이 성공적으로 실행될 것이라 보는 것\" 이라 할 수 있을 것 같다.  그렇다면 낙관적 개발은 \"어떤 공정이 성공적으로 실행될 것이라 가정하고, 개발하는 것\" 이라 해석할 수 있다. 성공과 실패의 여부를 확인한…","fields":{"slug":"/OptimisticUI/"},"frontmatter":{"date":"August 03, 2025","title":"낙관적 UI 알아보기","tags":["Optimistic-UI"]},"rawMarkdownBody":"## 낙관적인 개발이란?\n![](Op_1.png)\n사전상 낙관은 \"미래를 밝고 희망적으로 보는 것\" 이라고 정의한다. 이런 의미를 개발에 접목하여 해석하면 **\"어떤 공정(task)이 성공적으로 실행될 것이라 보는 것\"** 이라 할 수 있을 것 같다. \n\n그렇다면 **낙관적 개발**은 **\"어떤 공정이 성공적으로 실행될 것이라 가정하고, 개발하는 것\"** 이라 해석할 수 있다. 성공과 실패의 여부를 확인한 후 다음 작업을 진행하는 순서가 아닌 일단 성공했다 가정한 후 결과에 따라 후처리(롤백, 재시도)를 진행하는 것이다.\n\n## 낙관적 UI\n낙관적 UI는 위에서 설명한 낙관적 개발 방식을 UI에 적용한 방식이라 할 수 있다. \n\n사용자가 어떤 요청(업데이트)을 진행하여 UI를 변경해야 하는 상황에서, **요청이 성공했다 가정**하고 **UI를 먼저 업데이트** 하는 것이다. 여기서 만약 요청이 실패한다면, 그때 실패에 대한 후처리를 진행한다.\n![일반적인 UI 업데이트 흐름](Op_2.jpeg)\n![낙관적 UI 업데이트 흐름](Op_3.jpeg)\n\n## 낙관적 UI를 사용하는 이유\n예를 들어, 정말 인터넷이 느린 환경에서 사용자가 어떤 게시물에 좋아요를 누른다고 가정하자. 만일 낙관적 UI를 사용하지 않는다면 좋아요를 누른 후 카운트가 변화하기까지 서버의 응답을 기다려야 하기 때문에 상당히 오랜 시간 좋아요의 카운트가 변하지 않을 것이다. 이로 인해 좋아요가 눌리지 않았거나, 요청이 실패하였다 착각하여 좋아요를 여러번 누르는 불편함이 발생할 것이다.\n\n하지만, 낙관적 UI를 사용한다면 좋아요 버튼을 누른 즉시 좋아요 카운트가 변하기 때문에 위와 같은 불편함을 해결할 수 있게 된다.\n\n이처럼, 낙관적 UI는 사용자 경험(UX) 향상을 위해 사용할 수 있으며, 예시를 든 좋아요 말고도 `실시간 메시지를 전송할 때`, `데이터 수정 후 수정 내용을 보여줄 때` 등에 적용할 수 있다.\n"},{"excerpt":"쿠키란? 서버에서 생성되어 클라이언트 측에 저장되는 데이터로, 상태를 유지하지 않는 HTTP의 특성을 보완하기 위한 수단이다.  쌍의 형태를 띠고 있으며, 추가로 적용 범위와 만료 기간 등 다양한 속성을 가질 수 있다. 서버는 쿠키를 생성하여 클라이언트에게 전송하고, 클라이언트는 전달받은 쿠키를 저장해 두었다가 추후 동일한 서버에 보내는 요청 메시지에 쿠…","fields":{"slug":"/HTTPCookie/"},"frontmatter":{"date":"June 16, 2025","title":"HTTP 쿠키","tags":["Network","쿠키"]},"rawMarkdownBody":"## 쿠키란?\n서버에서 생성되어 클라이언트 측에 저장되는 데이터로, 상태를 유지하지 않는 HTTP의 특성을 보완하기 위한 수단이다. `<이름, 값>` 쌍의 형태를 띠고 있으며, 추가로 적용 범위와 만료 기간 등 다양한 속성을 가질 수 있다.\n\n서버는 쿠키를 생성하여 클라이언트에게 전송하고, 클라이언트는 전달받은 쿠키를 저장해 두었다가 추후 동일한 서버에 보내는 요청 메시지에 쿠키를 포함하여 전송한다. 주로 로그인 상태를 유지하는 기능에 사용된다.\n![](C_1.png)\n\n> **세션 인증**\n> \n> 쿠키에서 보내는 정보를 바탕으로 서버에서 매번 인증 과정을 거치지 않기 위해 서버에서는 **세션 아이디**를 클라이언트에 전송하는 방식으로 인증 과정을 건너뛰는 방법을 사용한다. 이를 **세션 인증**이라고 한다.\n> </br>\n> </br>\n> 세션 아이디는 `Set-Cookie`헤더를 통해 전달하며, 다음과 같은 세션 인증 과정을 통해 클라이언트를 식별한다.\n> 1. 클라이언트는 서버에게 (아이디, 비밀번호와 같은) 인증 정보를 전송한다.\n> 2. 인정 정보가 올바르다면, 서버는 세션 아이디를 생성해 클라이언트에게 전송한다.\n> 3. 클라이언트는 추후 요청을 보낼 때 쿠키 내에 세션 아이디를 포함하여 전송한다.\n> 4. 서버는 쿠키 속 세션 아이디와 저장된 세션 아이디를 비교하여 클라이언트를 식별한다.\n\n## 쿠키와 관련된 헤더\n쿠키를 전송하거나 서버에서 전송한 쿠키를 저장하는 과정은 `Set-Cookie` 헤더와 요청 메시지의 `Cookie` 헤더를 통해 이루어 진다.\n\n응답 메시지의 `Set-Cookie` 헤더를 통해 쿠키의 이름, 값과 더불어 세미콜론(;)으로 구분되는 속성들을 전달할 수 있다.\n![Set-Cookie 응답 메시지](C_2.png)\n\n요청 메시지의 Cookie 헤더 값은 서버에 전달할 쿠키의 이름과 값을 나타내는 헤더이다. 여러개의 쿠키 값을 서버에 전달해야 할 때는 다음과 같이 세미콜론(;)을 사용하여 여러 쿠키의 `이름-값`을 나타낼 수 있다.\n![Cookie 응답 메시지](C_3.png)\n## 브라우저에서 쿠키 살펴보기\n쿠키는 브라우저에서 저장되고 관리된다. 크롬 브라우저에서 개발자 도구를 열고, `Application` -> `Storage`-> `Cookies`를 확인하면 다음과 같이 쿠키의 이름, 값 목록을 볼 수 있다.\n![브라우저에서 본 쿠키](C_5.png)\n\n쿠키 관련 정보로 이름과 값 외에 `도메인`과 `경로`등이 있는 것을 볼 수 있는데, 이는 쿠키를 올바른 도메인과 경로에 전송하기 위한 속성 값들이다. 도메인의 경우 `Set-Cookie` 헤더의 `'domain'`속성으로 정해지고, 같은 도메인에서도 하위 경로마다 쿠키를 다르게 설정하고 싶다면 `'path'`속성에 하위 경로를 입력하여 설정할 수 있다.\n![domain 응답 메시지](C_6.png)\n![path 응답 메시지](C_7.png)\n\n`Expires/Max-Age`라는 열은 쿠키의 유효 기간을 나타낸다. 쿠키는 보통 유효 기간이 정해져 있기 때문에 `Expires`는 `요일, DD-MM-YY HH:MM:SS GMT` 형식으로 표기되는 만료 시점을 의미하고, `Max-Age`는 초 단위 유효 기간을 의미한다. `Expires/Max-Age`로 명시된 유효기간이 지나면 해당 쿠키는 삭제 되거나 전달되지 않는다.\n![Expires/Max-Age 응답 메시지](C_8.png)\n## 쿠키의 한계\n쿠키는 사용하기 간편한 만큼 보안적인 측면에서 한계가 있다. 쿠키의 정보는 쉽게 노출 되거나 조작할 수 있기 때문에 보통 쿠키에는 민감한 정보를 담아 송수신 하는걸 권장하지 않는다.\n\n하지만 이런 문제점을 보롼하기 위해 `Secure`속성과 `HttpOnly`라는 속성이 있다.\n\n`Secure`속성은 HTTPS 프로토콜이 사용되는 경우에만 쿠키를 전송되도록 하는 속성이다. HTTPS 프로토콜은 송수신시 정보가 암호화되기 때문에 보다 안전한 쿠키 전송이 가능하다.\n\n`HttpOnly`속성은 HTTP 송수신을 통해서만 쿠키를 이용하도록 제한하는 속성이다. 쿠키는 HTTP 송수신 외 자바스크립트를 통해 접근이 가능한데, 이로 인해 중간에 쿠키를 가로채거나 위조할 위험이 있기 때문에 HTTP 송수신으로만 쿠키에 접근 가능하도록 제안하는 것이다.\n\n\n> **웹 스토리지: 로컬 스토리지와 세션 스토리지**\n> \n> 쿠키 이외에도 `<키-값>`으로 정보를 저장하는 방법이 있다. 바로 웹 스토리지에 저장하는 것이다. \n> </br>\n> </br>\n> 웹 스토리지에는 웹 브라우저 내의 저장 공간으로, 일반적인 쿠키보다 더 큰 데이터를 저장할 수 있다. 또 쿠키는 서버로 자동 전송되지만, 웹 스토리지의 정보는 서버로 자동 전송되지 않는다.\n> </br>\n> </br>\n> 웹 스토리지에는 크케 **로컬 스토리지**와 **세션 스토리지**가 있다. 로컬 스토리지는 별도로 삭제하지 않는 한 영구적으로 정보 저장이 가능하며, 세션 스토리지는 세션이 유지되는 동안(브라우저가 열려 있는 동안) 유지되는 정보이다.\n\n\n\n\n\n\n"},{"excerpt":"캐시란 불필요한 대역폭 낭비와 응답 지연을 방지하기 위해 정보의 사본을 임시로 저장하는 기술이다.  캐시는 웹 브라우저에 저장되는 개인 전용 캐시(private cache) 와 중간 서버에 저장되는 공용 캐시(public cache) 가 있다.  캐시는 어디까지나 임시의 사본이기 때문에 원본 데이터가 바뀐다면 캐시도 갱신해야 한다는 절대적인 원칙이 있다.…","fields":{"slug":"/HTTPCache/"},"frontmatter":{"date":"June 14, 2025","title":"HTTP 캐시","tags":["Network","캐시"]},"rawMarkdownBody":"캐시란 불필요한 대역폭 낭비와 응답 지연을 방지하기 위해 정보의 사본을 임시로 저장하는 기술이다.  캐시는 웹 브라우저에 저장되는 **개인 전용 캐시(private cache)** 와 중간 서버에 저장되는 **공용 캐시(public cache)** 가 있다. \n\n캐시는 어디까지나 임시의 사본이기 때문에 원본 데이터가 바뀐다면 캐시도 갱신해야 한다는 절대적인 원칙이 있다. 이때 특정 캐시의 최신 원본 데이터와의 유사도를 **캐시 신선도**라고 표현하기도 한다. 캐시의 신선도를 유지하기 위한 방법은 **캐시된 데이터의 유효기간을 설정**하는 방법이 있다. \n\n## 캐시의 유효기간 설정\n캐시의 유효기간을 부여하는 방법은 응답 메시지의 Expires 헤더와 Cache-Control 헤더의 Max-Age 값(초)을 이용할 수 있다. \n\n![](HC_1.png)\n위의 응답 메시지는 각각 캐시의 유효 기간을 2024년 2월 6일 화요일 12:00:00로 설정하고, 1200초로 설정하는 응답 메시지이다.\n\n## 캐시의 신선도 재검사\n![](HC_2.png)\n만약 캐시의 유효기간이 만료되어 서버에게 자원을 다시 요청해야 하는 상황일 때, 원본 데이터가 캐시와 차이점이 없다면 서버는 굳이 같은 자원을 다시 전송할 이유가 없다. \n\n이처럼 캐시가 만료되더라도 캐시된 자원이 여전히 신선한지를 검사하기 위해 주로 **날짜 기반으로 서버에게 물어보거나**, **엔티티 태그를 기반으로 서버에게 물어보는 방법**을 사용한다.\n\n### 날짜 기반 재검사\n날짜 기반으로 재검사 하는 방식은 `If-Modified-Since` 헤더를 통해 특정 날짜 이후에 원본 데이터의 변경이 있었는지 판단하는 방법을 사용한다. \n\n![2024년 8월 25일 금요일 09:00:00 이후에 www.example.com/index.html의 자원이 변경 되었을 경우에만 새 자원으로 응답하라는 요청](HC_3.png)\n위와 같이 `If-Modified-Since` 헤더가 담긴 요청 메시지를 보낸다면 서버에서는 상황에 따라 다음과 같은 응답을 제공한다.\n- **200(OK)**: 자원이 변경되어 새로운 자원을 반환한다.\n- **304(Not Modified)**: 자원이 변경되지 않음.\n- **404(Not Found)**: 요청 받은 자원이 삭제됨 (찾을 수 없음).\n\n여기서 304응답의 경우 `Last-Modified`라는 헤더를 통해 마지막으로 수정된 시점을 알 수 있다.\n#### 엔티티 태그 기반 재검사\n![](HC_4.png)\n**엔티티 태그**란 **자원의 버전**을 식별하기 위한 정보로 자원에 유의미한 변경 사항이 생길 시 매번 다른 엔티티 태그가 할당된다. 만약 현재 클라이언트의 엔티티 태그와 서버 원본 자원의 엔티티 태그가 같다면 이는 유의미한 변경이 일어나지 않았다는 것을 의미한다.\n\n![abc라는 엔티티 태그의 자원이 없을 경우에만 새 자원으로 응답하라는 요청](HC_5.png)\n엔티티 태그를 이용하여 서버에 요청하기 위해서는 `If-None-Match`헤더를 사용해야 한다. 해당 헤더에 캐시의 엔티티 태그를 담아 요청하면 아래와 같은 응답을 제공한다.\n- **200(OK)**: 자원의 엔티티 태그가 변경되어 새로운 자원을 반환한다.\n- **304(Not Modified)**: 자원이 변경되지 않음 (엔티티 태그 값이 같음). \n- **404(Not Found)**: 요청 받은 자원이 삭제됨 (찾을 수 없음)."},{"excerpt":"HTTP 헤더 HTTP 헤더는 요청시 활용되는 헤더와 응답 시 활용되는 헤더, 그리고 요청과 응답 모두에서 자주 활용되는 헤더순으로 설명할 수 있다. 요청 시 활용되는 HTTP 헤더 1. Host 요청을 보낼 호스트를 나타내는 헤더이다. 주로 도메인 네임으로 명시되며, 포트 번호가 포함되어 있을 수 있다. 아래 예시는 http://naver.com/use…","fields":{"slug":"/HTTPHeader/"},"frontmatter":{"date":"June 11, 2025","title":"HTTP 헤더","tags":["Network","HTTP-헤더"]},"rawMarkdownBody":"## HTTP 헤더\nHTTP 헤더는 요청시 활용되는 헤더와 응답 시 활용되는 헤더, 그리고 요청과 응답 모두에서 자주 활용되는 헤더순으로 설명할 수 있다.\n\n### 요청 시 활용되는 HTTP 헤더\n#### 1. Host\n요청을 보낼 호스트를 나타내는 헤더이다. 주로 도메인 네임으로 명시되며, 포트 번호가 포함되어 있을 수 있다. 아래 예시는 http://naver.com/user 에 접속할 때의 HTTP 요청 메시지의 일부이다.\n```text\nGet /user HTTP/1.1\nHost: naver.com\n...\n```\n\n#### 2. User-Agent\n**유저 에이전트**란 웹 브라우저와 같이 HTTP 요청을 시작하는 클라이언트 측의 프로그램을 의미한다. 따라서 User-Agent 헤더에는 요청 메시지 생성에 관여한 클라이언트의 운영체제, 브라우저 종류 및 버전, 렌더링 엔진과 같은 정보가 포함되어 있다.\n![User-Agent헤더 예시](HH_1.png)\n\n#### 3. Referer\n클라이언트가 요청을 보낼 때 머무르고 있던 URL이 명시된다. 해당 헤더를 통해 클라이언트의 유입 경로를 파악해 볼 수 있다.\n\n다음 헤더는 https://google.com 에서 요청을 보냈음을 의미한다.\n```text\nReferer: https://google.com\n```\n여담으로, 영문법 상 Referrer이 맞는 표기지만 개발 초기 오류로 인해 지금까지 Referer로 사용되고 있다.\n\n#### 4. Authorization\n클라이언트의 인증 정보를 담는 헤더이다. 표기 방식은 다음과 같이 **인증 타입**과 **인증을 위한 정보**가 차례로 명시된다. \n```text\nAuthorization: <type> <credentials>\n```\n\n### 응답 시 활용되는 HTTP 헤더\n#### 1. Server\n요청을 처리하는 서버 측의 소프트웨어와 관련된 정보를 명시한다. 예시로 다음과 같은 헤더는 'Unix 운영체제에서 동작하는 아파치 HTTP 서버'를 의미한다.\n```text\nServer: Apache/2.4.1 (Unix)\n```\n\n#### 2. Allow\n클라이언트에게 허용된 HTTP 메서드 목록을 알려 주기 위해 사용된다. 주로 405(Method Not Allowed)를 응답하는 메시지에 Allow 헤더가 함께 사용된다.\n![POST, OPTIONS 메서드만 허용한다는 의미](HH_2.png)\n\n#### 3. Retry-After\n503(Service Unavailable)의 상태 코드 응답에서 사용될 수 있는 헤더이다. 자원을 사용할 수 있는 날자 혹은 시간을 나타낸다.\n\n#### 4. Location\n클라이언트에게 자원의 위치를 알려 주기 위해 사용되는 헤더이다. 주로 리다이렉션이 발생했을 때나 새로운 자원이 생성되었을 때 사용된다.\n\n#### 5. WWW-Authenticate\n401(Unauthorized)상태 코드일때, 인증 방식을 설명하는 헤더이다. 인증 타입을 알려 줄수 있으며, 조금더 많은 정보를 알려주기 위해 다음과 같이 **보안 영역(realm)** 을 함께 알려주거나 인증에 사용될 **문자 집합**도 알려 줄 수 있다.\n```text\nWWW-Authenticate: Basic realm=\"Access to engineering site\", charset=\"UTF-8\"\n```\n> **realm이란?**\n> \n> realm이란 보안이 적용될 영역을 의미한다. 영역이 달라지면 요구되는 권한도 달라질 수 있다.\n\n### 요청과 응답 모두에서 활용되는 HTTP 헤더\n#### 1. Date\n메시지가 생성된 날짜와 시각에 관련된 정보를 담은 헤더이다.\n\n#### 2. Connection\n클라이언트의 요청과 응답 간의 연결 방식을 설정하는 헤더이다. HTTP가 지속 연결 프로토콜을 유지하기 위해 명시적으로 `keep-alive`를 희망함을 표기하는 헤더이기도 하다. \n```text\nConnection: keep-alive\nConnection: close\n```\n\n#### 3. Content-Length\n본문의 바이트 단위 크기(길이)를 나타낸다.\n``` text\nContent-Length: 100\n```\n\n#### 4. Content-Type, Content-Language, Content-Encoding\n해당 헤더들은 전송하려는 메시지 본문의 표현 방식을 설명하는 헤더이다. 이런 점에서 **표현 헤더**의 일종이라고도 부른다. \n\n**Content-Type** 헤더는 메시지 본문에서 사용된 미디어 타입을 담고 있다. 다음 헤더는 메시지 본문이 HTML문서 형식이며, 문자 인코딩으로 UTF-8을 사용한다는 정보를 알려준다.\n```text\nContent-Type: text/html; charset=UTF-8\n```\n\n**Content-Language** 헤더는 메시지 본문에 사용된 자연어를 명시한다. 어떤 언어로 작성되었는지 해당 헤더를 통해 알 수 있으며, 하이픈으로 구분된 언어 태그로 작성되어 있다. `en`, `ko`일 경우 첫 번째 태그만 사용된 것이고, `en-US`, `ko-KR`일 경우 두 번째 서브 태그까지 사용된 것이다.\n\n| 국가  | 국가 코드 |     |  언어  | 언어 코드 |\n| :-: | :---: | --- | :--: | :---: |\n| 한국  |  KR   |     | 한국어  |  ko   |\n| 미국  |  US   |     |  영어  |  en   |\n| 영국  |  GB   |     | 중국어  |  zh   |\n| 중국  |  CN   |     | 일본어  |  ja   |\n| 타이완 |  TW   |     | 독일어  |  de   |\n| 일본  |  JP   |     | 프랑스어 |  fr   |\n| 독일  |  DE   |     |      |       |\n| 프랑스 |  FR   |     |      |       |\n\n**Content-Encoding** 헤더는 메시지 본문을 압축하거나 변환한 방식이 명시된다. HTTP를 통해 송수신 되는 데이터는 전송 속도 개선을 위해 종종 압축이나 변환이 되는데, 이때 사용된 방식을 인식하고, 압축을 헤제하거나 원문으로 재변환하여 본문 내용을 확인할 수 있다.\n```text\nContent-Encoding: gzip\nContent-Encoding: compress\nContent-Encoding: deflate\nContent-Encoding: br\n\n// 여러 인코딩이 사용되었을 경우 적용된 순서대로 명시\nContent-Encoding: deflate, gzip\n```"},{"excerpt":"우리가 흔히 안정성 있는 시스템을 말하면, 언제든 원활하게 접근 가능한 시스템을 말하는 것 처럼 안정성은 \"특정 기능을 언제든 균일한 성능으로 수행할 수 있는 특성\"이라 정의할 수 있다. 가용성 이런 안정성의 정도를 나타내는 용어로 가용성과 고가용성이 있다.  가용성이란, \"컴퓨터 시스템이 특정 기능을 실제로 수행할 수 있는 시간의 비율\"을 의미한다. 정…","fields":{"slug":"/StabilitySkill/"},"frontmatter":{"date":"June 10, 2025","title":"네트워크의 안정성을 위한 기술","tags":["Network","안정성"]},"rawMarkdownBody":"우리가 흔히 안정성 있는 시스템을 말하면, 언제든 원활하게 접근 가능한 시스템을 말하는 것 처럼 안정성은 \"특정 기능을 언제든 균일한 성능으로 수행할 수 있는 특성\"이라 정의할 수 있다.\n## 가용성\n이런 안정성의 정도를 나타내는 용어로 **가용성**과 **고가용성**이 있다. \n\n가용성이란, \"컴퓨터 시스템이 특정 기능을 실제로 수행할 수 있는 시간의 **비율**\"을 의미한다. 정상적으로 사용할 수 있는 시간을 **업타임**, 사용할 수 없는 시간을 **다운타임**이라 정의하며, 가용성을 수식으로 나타내면 다음과 같다.\n$$\n가용성 = \\frac{업타임}{업타임 + 다운타임}\n$$\n`업타임 + 다운타임`은 **전체 사용중인 시간**이며 전체 사용중인 시간중 사용 가능한 시간의 비율을 가용성이라 할 수 있다. 가용성이 높다는 것은 사용 가능한 시간이 많다는 것이고 가용성이 높은 성질을 **고가용성(High Availability; HA)** 이라 부른다.\n\n보통 가용성을 표기할 때는 백분율을 사용하며, 일반적으로 안정적이라 평가받는 시스템은 **99.999%** 이상을 목표로 한다. 이를 **파이브 나인즈**라고도 한다.\n\n![가용성에 따른 다운타임 표](ST_1.png)\n\n가용성을 높이기 위해서는 다운타임을 줄여야 하지만, 정말 예기치 못한 상황에서 발생하는 다운타임을 막는것은 현실적을 불가능 하다. 때문에 문제를 발생하지 않도록 하는것이 아니라 **문제가 발생하더라도 계속 기능할 수 있도록 설계**하는 것을 목표로 두어야 하며, 이러한 능력을 **결함 감내**라 부른다.\n\n## 이중화\n이중화는 말 그대로 **무언가를 이중으로 두는 기술**이다. 문제가 발생한다면 시스템 전체를 운영할 수 없는 부분을 찾아 이중화를 진행해야 하며, 이러한 부분을 **단일 장애점(Single Point Of Failure; SPOF)** 라고 한다.\n![해당 사진에서 SPOF는 라우터이다](ST_2.png)\n\n### 이중화의 구성\n이중화의 방식에는 크게 두 가지가 있다.\n\n- **액티브/스탠바이**\n- **액티브/액티브**\n\n**액티브/스탠바이** 방식의 경우 이중화된 시스템에서 평소에는 하나의 장비만 작동시키다가, 작동하는 장비에 문제가 발생하였을때, 대기하고 있는 장비가 작동하여 시스템의 운영을 이어가는 방식이다. 이는 안전한 구성 방식이지만, 하나의 장비를 사용할 때에 비해 성능항의 큰 변화를 기대하기 어렵다는 단점이 있다.\n\n**액티브/엑티브** 방식의 경우 두 장비 모두 가동시키는 방식이다. 이론상 두 장비 모두 문제가 생기지 않는 이상 시스템의 안정성을 보장할 수 있으며, 성능상의 이점도 있다.\n\n![액티브/스탠바이, 액티브/액티브 방식](ST_3.png)\n## 다중화\n다중화는 **이중화보다 더많은 장비 혹은 무언가를 여러개 두는 기술**이다. 당연히 이중화된 구성에 비해 더욱 안정적인 운영이 가능하며, 다중화의 사례로는 **티밍**과 **본딩**이 있다.\n- **티밍**: 주로 윈도우에서 사용되는 용어\n- **본딩**: 주로 리눅스에서 사용되는 용어\n\n## 로드 밸런싱\n로드 벨런싱은 서버에서의 고가용성을 위해 트래픽을 고르게 분산하기 위한 기술이다. 로드 벨런싱은 **로드 밸런서**에 의해 수행되며 로드 밸런서는 'L4 스위치', 'L7 스위치'와 같은 네트워크 장비 혹은 로드 밸런싱 기능을 제공하는 소프트웨어를 의미한다.\n![로드 밸런서의 위치 사진](ST_4.png)\n\n일반적으로 로드 밸런서는 이중화나 다중화된 서버와 클라이언트 사이에 위치하여 **로드 밸런싱 알고리즘**을 통해 요청을 각 서버에 균등하게 분배한다. 로드 밸런싱 알고리즘은 대표적으로 다음과 같은 것들이 있다.\n\n- `라운드 로빈 알고리즘`: 서버를 돌아가며 부하를 전달하는 알고리즘\n- `최소 연결 알고리즘`: 연결이 적은 서버부터 우선적으로 부하를 전달하는 알고리즘\n- 단순히 무작위로 고르는 알고리즘\n- 해시(hash) 자료구조를 이용하는 알고리즘\n- 응답 시간이 가장 짧은 서버를 선택하는 알고리즘 등..\n\n![라운드 로빈 알고리즘](ST_5.png)\n![가중치 라운드 로빈 알고리즘](ST_6.png)\n서버의 성능에 따라 가중치를 부여하여 적용할 수도 있는데, **가중치 라운드 로빈 알고리즘**과 **가중치 최소 연결 알고리즘**이 대표적이다.\n\n> **서버의 상태를 검사하는 헬스 체크**\n> \n> 다중화된 서버 환경에서 문제가 없는 서버를 찾아 요청을 보내기 위해 로드 밸런서는 서버의 상태를 주기적으로 검사한다. 이러한 검사를 **헬스 체크**라고 하며 HTTP, ICMP등 다양한 프로토콜을 활용할 수 있다.\n> </br>\n> </br>\n> 로드 밸런서가 주도하는 헬스 체크 이외에도 서버 간에 **하트비트**라는 메시지를 주기적으로 주고 받는 방법도 있다."},{"excerpt":"HTTP의 특성 Hypertext Transfer Protocol의 약자로 응용 계층에서 정보를 주고 받는데 사용되는 프로토콜이다.  요청-응답 기반 프로토콜 HTTP는 클라이언트와 서버가 서로 HTTP 요청 메시지와 HTTP 응답 메시지를 주고 받는 구조로 동작한다. 그렇기 때문에 같은 HTTP를 따른다 하더라도 요청 HTTP 메시지와 응답 HTTP 메…","fields":{"slug":"/HTTP/"},"frontmatter":{"date":"May 30, 2025","title":"HTTP","tags":["Network","HTTP"]},"rawMarkdownBody":"## HTTP의 특성\nHypertext Transfer Protocol의 약자로 응용 계층에서 정보를 주고 받는데 사용되는 프로토콜이다. \n\n### 요청-응답 기반 프로토콜\nHTTP는 클라이언트와 서버가 서로 HTTP 요청 메시지와 HTTP 응답 메시지를 주고 받는 구조로 동작한다. 그렇기 때문에 같은 HTTP를 따른다 하더라도 요청 HTTP 메시지와 응답 HTTP 메시지의 형태가 다르다.\n\n### 미디어 독립적 프로토콜\nHTTP는 **자원**을 주고 받는다 하였는데, 이 자원이란 정확히 어떤 것을 특정하는 것이 아니다. HTTP에서의 **자원**은 `HTML`, `JPEG`, `PNG`, `JSON`, `XML`, `PDF`등 다양한 종류를 의미할 수 있으며 HTTP는 주고 받을 자원의 특정과 무관하게 그저 **자원을 주고 받을 수단(인터페이스)** 의 역할만 수행한다.\n\n여기서 HTTP의 자원 종류를 **미디어 타입(media type, MIME Type)** 이라고 부른다. 미디어 타입은 일종의 웹 확장자와 같은 개념이다. 기본적으로 \"*타입/서브타입*\" 형식으로 구성된다.\n\n- `타입`: 데이터 유형\n- `서브타입`: 주어진 타입에 대한 세부 유형\n\n![미디어 타입 표](H_2.png)\n미디어 타입에는 (\\*)을 사용하여 여러 미디어 타입을 통칭하기도 한다. `text/*` 는 text 타입의 모든 서브타입을 나타내며 `*/*`은 모든 미디어 타입을 나타낸다.\n\n부과적인 설명을 위해 선택적으로 매개변수를 포함 시킬 수도 있다. 형식은 아래와 같다.\n![매개변수를 포함한 미디어 타입](H_1.png)\n\n### 스테이트리스 프로토콜\nHTTP는 상태를 유지하지 않는 **스테이트리스** 프로토콜이다. 서버가 HTTP 요청을 보낸 클라이언트와 관련된 상태를 기억하지 않는다는 것을 의미하며, HTTP의 설계 목표인 **확장성**과 **견고성**을 지키기 위해 **스테이트리스**하게 설계 되었다.\n\n만약 HTTP가 스테이트하게 설계 되었다면, 클라이언트가 서버에 종속되어 특정 서버를 의존하는 문제가 발생할 수 있고, 서버가 고장나거나 추가로 서버를 확장해야 할 때 유연한 대처가 불가능해 질 수 있다.\n![](H_3.png)\n\n### 지속 연결 프로토콜\nHTTP는 TCP상에서 동작하는 프로토콜 이지만, HTTP의 경우 TCP와 다르게 **비연결형** 프로토콜이다. 비연결형 프로토콜이기 때문에 과거 `HTTP/1.0`이하에서는 매번 요청과 응답을 할 때마다 쓰리핸드셰이크를 통해 TCP 연결을 수립한 후 요청을 하고 응답을 받으면 TCP연결을 종료하는 과정을 거쳐야만 했다.\n\n이런 비효율적인 문제를 해결하기 위해 **지속 연결(;keep-alive)** 이라는 기술을 제공하게 되었다. 지속 연결은 하나의 TCP 연결상에서 여러 개의 요청-응답을 주고 받을 수 있는 기술이다. 이로 인해 기존에 매번 새롭게 연결을 수립하는 비지속 연결에 비해 더 빠른 HTTP 요청-응답 처리가 가능해졌다.\n![비지속 연결과 지속 연결](H_4.png)\n## HTTP 메시지 구조\n`HTTP/1.1`의 기준으로 HTTP 메시지의 구성을 살펴보면 다음과 같다.\n![HTTP 메시지 구조](H_5.png)\n### 시작라인\n시작라인은 요청 메시지인지 응답 메시지인지에 따라 **요청 라인**, **상태 라인**이 된다.\n\n요청 라인의 경우 아래 사진과 같은 구성으로 이루어져 있다.\n![요청 라인](H_6.png)\n- `메서드`: 클라이언트가 서버의 자원에 대해 수행할 작업 (GET, POST, DELETE 등)\n- `요청 대상`: HTTP 요청을 보낼 서버의 자원을 의미한다. 쿼리가 포함된 URL의 경로(path)가 명시된다. `http://www.example.com/hello?q=world`로 요청을 보내면 요청 대상은 `/hello?q=world`가 된다. 하위 경로가 없다면 `/`가 요청 대상이 된다.\n- `HTTP 버전`: 이름 그대로 HTTP의 버전이 명시된다. `HTTP/버전` 표기 방식을 따른다.\n\n상태 라인의 경우 아래 사진과 같은 구성으로 이루어져 있다.\n![상태 라인](H_7.png)\n- `HTTP 버전`: HTTP의 버전이 명시된다. `HTTP/버전` 표기 방식을 따른다.\n- `상태 코드`: 요청에 대한 결과를 나타내는 세 자리 정수이다. (200, 404 등)\n- `이유 구문`: 상태 코드에 대한 문자열 형태의 설명을 의미한다. (OK, Not Found 등)\n\n### 필드 라인\n필드 라인에는 0개 이상의 HTTP 헤더가 명시된다. 그래서 **헤더 라인**이라 부르기도 한다. HTTP 헤더란 HTTP 통신에 필요한 부가 정보를 의미하며 콜론(:)을 기준으로 **헤더 이름**과 하나 이상의 **헤더 값**으로 구성된다. \n- `Content-Type: application/json` (헤더 이름: 헤더 값)\n\n![필드 라인의 헤더](H_8.png)\n### 메시지 본문\nHTTP 요청 혹은 응답 메시지에서 본문이 필요할 경우 **메시지 본문**에 명시된다. 메시지 본문은 없을 수도 있으며, 다음과 같이 다양한 콘텐츠 타입이 사용될 수 있다.\n![메시지 본문](H_9.png)\n## HTTP 메서드\nHTTP 요청 메시지에는 다양한 메서드들을 사용하여 자원에 대해 수행할 작업을 명시할 수 있다.\n![HTTP 메서드 표](H_10.png)\n### GET\n- 특정 자원을 조회할 때 사용되는 메서드\n- 대부분의 웹브라우저를 통해 조회하는 자원의 메서드가 GET\n- GET 메서드에서 요청 메시지 본문을 포함시키지 않는것이 바람직함\n- 메시지 본문보다 쿼리 문자열이 사용되는 경우가 많음\n\n### HEAD\n- GET 메서드와 동일한 역할을 하나, 응답 메시지에 메시지 본문이 포함되지 않음\n- \"헤더만 가져다주세요\" 같은 요청\n\n### POST\n- 서버로 하여금 특정 작업을 처리하도록 요청하는 메서드\n- 처리할 대상은 흔히 메시지 본문으로 명시됨 (body)\n- 보통 새로운 자원을 생성하고자 할 때 사용함\n\n### PUT\n- 덮어쓰기를 요청하는 메서드\n- 요청 자원이 없다면 메시지 본문으로 자원을 새롭게 생성하거나, 이미 자원이 존재한다면 메시지 본문으로 자원을 완전히 대체함\n\n### PATCH\n- 부분적 수정을 요청하는 메서드\n- PUT 메서드가 완전한 대체에 가깝다면, PATCH 메서드는 부분적 수정에 가까움\n\n### DELETE\n- 특정 자원을 삭제하고 싶을 때 사용하는 메서드\n\n## HTTP 상태 코드\n![HTTP 상태 코드 표](H_11.png)\n### 200번대: 성공 상태 코드\n![200번대 코드 표](H_12.png)\n요청이 성공했음을 의미한다. 만약 POST 요청을 통해 서버에 새로운 자원을 생성한 경우, 상태 코드 201(Created)로 요청이 성공했으며 새로원 자원이 만들어졌음을 알릴 수 있다. 이 경우 Location 헤더를 통해 생성된 자원의 위치를 명시할 수 있다.\n\n### 300번대: 리다이렉션 상태 코드\n300번대 코드는 **리다이렉션**과 관련된 코드이다. **리다이렉션**이란 \"요청을 완수하기 위해 추가적인 조치가 필요한 상태\"로 정의 한다. 쉽게 생각해 클라이언트의 요청을 다른 곳으로 이동시키는 것이다.\n\n클라이언트가 요청한 자원이 다른 URL에 있을 경우, 서버는 응답 메시지의 Location 헤더를 통해 요청한 자원이 위치한 URL을 안내해 줄 수 있다. \n![리다이렉션 과정](H_13.png)\n\n리다이렉션은 **영구적인 리다이렉션**과 **일시적인 리다이렉션**으로 구분할 수 있다. \n\n**영구적인 리다이렉션**은 자원이 완전히 새로운 곳으로 이동하여 경로가 **영구적**으로 재지정되는 것을 의미한다. 이 경우 기존의 URL에 요청 메시지를 보내면 **항상 새로운 URL**로 리다이렉트 된다. 관련된 상태 코드는 아래와 같다.\n![영구적인 리다리렉션 관련 상태 코드](H_14.png)\n둘의 차이는 **재요청 메서드 변경 여부**에 있다. 301의 경우 `GET`요청으로 바뀔 '수도' 있다 라는 의미이고, 308은 바뀌지 않는다는 의미이다.\n\n**일시적인 리다이렉션**은 자원의 위치가 임시로 변경되었거나 임시로 사용할 URL이 필요한 경우 사용된다. 임시적인 리다리렉션 URL이 응답으로 오기 때문에 따로 기억해둬야 한다. 관련 상태 코드는 아래와 같다.\n![일시적인 리다이렉션 관련 상태 코드](H_15.png)\n302 코드는 301과 비슷하게 재요청 메서드가 `GET`으로 바뀔 '수도' 있다는 의미이다. 307 코드는 308 코드와 같이 메서드가 변경되지 않는다는 의미이다. 303코드는 재요청 메서드가 `GET`으로 변경된다는 의미이다.\n\n리다이렉션의 다른곳으로 이동시키는 \"다른곳\"은 URL이 될 수도 있고 캐시가 될 수도 있다.\n### 400번대: 클라이언트 에러 상태 코드\n400번대 코드는 클라이언트에 의한 에러가 있음을 알려주는 상태 코드이다. 서버가 처리할 수 없는 형태로 요청을 보내거나 존재하지 않는 자원에 대해 요청을 보내는 경우가 속한다.\n![400번대 코드 표](H_16.png)\n\n400번 코드는 클라이언트의 요청이 잘못되었음을 알려주는 상태 코드이다. 요청 메시지의 내용이나 형식 자체에 문제가 있어 서버가 요청 메시지를 올바르게 처리할 수 없는 경우가 속한다.\n![](H_17.png)\n\n401코드는 **인증**이 필요한 경우 나타나는 코드이다. 특정 자원에 접근할 때 해당 자원에 접근하기 위한 인증 방법을 헤더에 명시해 주어야 하는데, 이게 없으면 발생한다.\n![WWW-Authenticate 헤더를 통해 인증 방법을 알려주어야 한다](H_18.png)\n\n403은 **권한**이 충분하지 않다는 상태 코드이다. 401과의 차이점은 이미 인증은 하였으나, 인증된 주체의 권한이 없기 때문에 나타나는 코드라는 것이다. **인증**이란 **'자신이 누구인지 증명하는 것'** 을 의미하고, **권한 부여**는 **'인증된 주체에게 작업을 허용하는 것'** 을 의미한다.\n\n404는 접근하고자 하는 자원이 존재하지 않을을 알리는 상태코드이다. 존재하더라도 공개하지 않는 자원에 대해서 404를 응답하는 경우도 있다.\n\n405는 해당 자원이 지원하지 않는 메서드로 요청을 하면 발생하는 코드이다. POST와 GET만 지원하는 자원에게 PATCH를 요청하면 405코드가 발생한다.\n### 500번대: 서버 에러 상태 코드\n500번대는 서버가 원인인 에러 코드이다. 클라이언트가 올바르게 요청을 보냈을지라도 발생할 수 있는 서버 에러에 대한 상태 코드이다.\n![500번대 코드 표](H_19.png)\n500번대 코드는 '서버의 예기치 못한 상황으로 인해 요청을 처리할 수 없음'을 의미한다. 포괄적인 의미에서 예측하지 못한 에러가 발생하였을때 일반적으로 500코드를 사용한다.\n\n502번대 코드는 클라이언트와 서버 사이에 위치한 중간 서버의 통신 오류를 나타내는 상태코드이다. 게이트웨이를 비롯한 여러 중간 서버중 잘못된 응답을 하거나 정상적이지 않을 때 발생하는 코드이다.\n![중간 서버에 문제가 발생한 상황](H_20.png)\n\n503번대 코드는 '현재 서비스를 일시적으로 사용할 수 없음'을 의미하는 상태코드이다. 서버가 과부하 상태에 있거나 일시적인 점검 상태일 때 볼 수 있는 상태 코드이다."},{"excerpt":"도메인 네임과 네임 서버 네트워크 상에서 어떤 호스트를 특정하기 위해 IP 주소를 사용하고 있다. 하지만 오로지 IP 주소만을 사용한다면 원하는 특정 호스트의 IP 주소를 모두 외워둬야 하는 문제가 발생한다. 이를 위해 IP 주소 대신 도메인 네임을 사용하며, 도메인 네임과 IP 주소는 네임 서버에서 관리한다. 이중 도메인 네임을 관리하는 네임 서버는 D…","fields":{"slug":"/DNS/"},"frontmatter":{"date":"May 23, 2025","title":"DNS와 자원","tags":["Network","DNS","URI"]},"rawMarkdownBody":"## 도메인 네임과 네임 서버\n네트워크 상에서 어떤 호스트를 특정하기 위해 IP 주소를 사용하고 있다. 하지만 오로지 IP 주소만을 사용한다면 원하는 특정 호스트의 IP 주소를 모두 외워둬야 하는 문제가 발생한다. 이를 위해 IP 주소 대신 **도메인 네임**을 사용하며, 도메인 네임과 IP 주소는 **네임 서버**에서 관리한다. 이중 도메인 네임을 관리하는 네임 서버는 **DNS서버** 라고도 한다.\n\n- `도메인 네임`: IP 주소 대신 사용하는 도메인의 이름\n- `네임 서버`: IP 주소와 도메인 네임을 관리하는 서버\n- `DNS 서버`: 도메인 네임을 관리하는 서버\n\n![](D_1.png)\n\n## 도메인 네임의 구조\n도메인 네임은 (.)을 기준으로 계층적으로 분류된다. 최상단에 **루트 도메인**이 있고, 그 다음에는 **최상위 도메인**, 계속 그 다음은 **n단계 도메인**이 있는 식이다.\n![도메인 네임의 계층 구조](D_2.png)\n\n일반적으로 알고있는 도메인 **네임의 마지막** 부분을 최상위 도메인이라 하며, 줄여서 **TLD** 라고 한다. 위 사진에서는 `com`, `kr`, `edu` 가 된다. 루트 도메인은 점(.)으로 표기 되는데, 일반적으로는 생략한다.\n\nwww.example.com. 과 같이 도메인 모두 포함하는 도메인 네임을 전체 주소 도메인 네임(FQDN)이라고 한다.\n![](D_3.png)\n\n이러한 계층적인 형태의 도메인 네임을 효율적으로 관리하기 위해 형성된 관리 체계를 **도메인 네임 시스템** 줄여서 **DNS**라고 부른다. DNS는 호스트가 이러한 도메인 네임 시스템을 이용할 수 있도록 하는 애플리케이션 계층 프로토콜을 의미하기도 한다.\n\n## 계층적 네임 서버\nIP 주소를 모르는 상태에서 도메인 이름을 통해 IP 주소를 알아내는 과정을 **리졸빙(resolve+ing)** 이라고 한다. 리졸빙을 하는 과정에서 다양한 네임 서버들이 사용되는데, 역할 담당에 따라 크게 4가지로 분류할 수 있다.\n\n- 로컬 네임 서버\n- 루트 네임 서버\n- TLD(최상위 도메인) 네임 서버\n- 책임 네임 서버\n\n![](D_4.png)\n\n### 로컬 네임 서버\n클라이언트와 맞닿아 있는 네임 서버로 클라이언트가 도메인 네임을 통해 IP 주소를 알아내고자 할 때 가장 먼저 찾게되는 네임 서버이다. 로컬 네임 서버의 주소는 일반적으로 ISP에서 할당해 준다.\n\n### 공개 DNS 서버\n만약 로컬 네임 서버를 사용하지 않는다면 사용할 네임 서버이다. 이름 그대로 공개 되어있는 DNS 서버 이므로 공개된 주소를 통해 접근 가능하다.\n\n대표적으로 `8.8.8.8`, `8.8.4.4`의 구글 DNS 서버와 `1.1.1.1`의 클라우트플레어의 공개 DNS 서버가 있다.\n\n### 루트 네임 서버\n**루트 네임 서버**는 루트 도메인을 관장하는 네임 서버로, 질의에 대해 TLD 네임 서버의 IP 주소를 반환할 수 있다.\n\n클라이언트가 로컬 네임 서버에서 특정 도메인 네임에 대응되는 IP 주소가 무엇인지 질의하였을 때, 만약 로컬 네임 서버가 해당 도메인 네임에 대응하는 IP 주소를 모른다면 **루트 네임 서버**에게 질의를 하게 된다. \n![](D_5.png)\n\n## TLD 네임 서버\n**TLD 네임 서버**는 TLD(최상위 도메인)를 관리하는 네임 서버이다. 루트 네임 서버와 비슷하게 TLD의 하위 도메인 네임을 관리하는 네임 서버 주소를 반환할 수 있다.\n![](D_6.png)\n## 책임 네임 서버\n**책임 네임 서버**는 특정 도메인 영역을 관리하는 네임 서버로, 자신이 관리하는 도메인 영역의 질의에 **곧바로 답할 수 있는 네임 서버**이다. 로컬 네임 서버가 마지막으로 질의하는 네임 서버이므로 일반적으로 책임 네임 서버에서 원하는 IP 주소를 얻을 수 있다.\n\n이와 같이 네임 서버들은 계층적인 구조를 통해 도메인 네임을 리졸빙 할 수 있다.\n![](D_7.png)\n\n## 리졸빙 방식\n도메인 네임을 리졸빙 하는 과정에서, 로컬 네임 서버가 각 도메인 네임 서버들에게 질의하는 방식을 크게 2가지로 나눌 수 있다.\n\n- 재귀적 질의\n- 반복적 질의\n\n### 재귀적 질의\n**재귀적 질의**는 클라이언트가 로컬 네임 서버에게 도메인 네임을 질의하면 로컬 네임 서버가 루트 네임 서버에게 질의하고, 루트 네임 서버가 TLD 네임 서버에 질의하고, TLD 네임 서버가 책임 네임 서버에게 질의하여 최종 응답 결과를 역순으로 전달받는 방식이다.\n![](D_8.png)\n### 반복적 질의\n**반복적 질의**는 클라이언트가 로컬 네임 서버에게 질의하면, 로컬 네임 서버가 루트 네임 서버에게 질의한 후 다음 단계 서버의 주소를 받고 다시 로컬 네임 서버가 받은 주소의 서버에 질의하는 반복적인 방식으로 최종 응답을 받는 방식이다.\n![](D_9.png)\n\n## DNS 캐시\n도메인 네임의 리졸빙 과정을 보면 상당히 많은 통신 과정이 필요하다는 것을 알 수 있다. 만약 매번 저런식으로 리졸빙을 하게 된다면 빠르게 네임 서버에 과부화가 발생할 것이다. 이런 문제를 해결하기 위해 네임 서버들은 **DNS 캐시**를 통해 응답받은 결과를 임시로 저장해 둔다. 임시 저장해둔 값은 지정된 **TTL**에 따라 자동으로 삭제된다.\n\n## 자원을 식별하는 URL\n- `자원(resource)`: 네트워크상의 메시지를 통해 주고 받는 대상. HTML 파일, 이미지, 동영상 파일 등 다양한 요소들이 있다.\n- `URI(Uniform Resource Identifier)`: 자원을 식별할 수 있는 정보라는 의미. HTTP 기반의 통신에서 여러 자원들중 특정 자원을 식별할 수 있는 통일된 방식\n\n자원을 식별하기 위한 `URI`에는 위치를 이용하여 식별하는 방식과 이름을 이용하여 식별하는 방식이 있다. 각각 `URL`과 `URN`이라고 부른다.\n\n### URL(Uniform Resource Locator)\n**URL**은 위치 기반 식별자로 특정 자원을 찾을때 위치를 기반으로 찾는 방식이다.\n![](D_10.png)\n\nURL의 형태는 인터넷 표준 문서에 소개되어 있으며 각 부분별로 표기되는 의미가 다르다.\n#### scheme\nURL의 첫 부분으로 **\"자원에 접근하는 방법\"** 을 의미한다. 일반적으로 프로토콜이 명시된다. \n\n- HTTP를 사용할 때 -> http://\n- HTTPS를 사용할 때 -> https://\n\n#### authority\n**\"호스트를 특정할 수 있는 정보\"** 가 담기기는 부분이다. 주로 IP 주소 혹은 도메인 네임이 명시된다. 콜론(:)뒤에 포트 번호를 덧붙일 수도 있다.\n\n#### path\n**\"자원이 위치한 경로\"** 가 명시된다. 자원의 위치는 슬래시(/)를 기준으로 계층적으로 표현되고, 최상위 경로 또한 슬래시로 표현된다. \n![a.png의 경로 사진](D_11.png)\n위와 같은 계층 구조에서 a.png에 접근하기 위한 URL의 path는 `/home/images/a.png`라고 표현할 수 있다.\n\n#### query\n요청-응답 기반의 HTTP 프로토콜에서 **\"특정 단어를 검색한 결과\"** 이나 **\"결과 내림차순 정렬\"** 과 같은 세부적인 요청 정보를 전달하기 위한 부분이다. 물음표(?)로 시작되는 <키=값> 형태의 데이터로 표현하며 `&`를 사용하여 여러 쿼리 문자열을 연결할 수 있다.\n![쿼리는 쿼리 문자열(query string), 쿼리 파라미터(query parameter)이라고도 한다](D_12.png)\n\n쿼리 문자열은 개발자의 설계에 따라 달라질 수 있으며, 쿼리 문자열을 통해 보다 유연한 서버와의 상호 작용이 가능해 진다.\n![지역과 침실 수, 면적, 최소 가격에 대한 정보를 쿼리에 담에 보낸 예시](D_13.png)\n#### fragment\n**\"자원의 한 조각을 가리키기 위한 정보\"** 이다. 흔히 HTML 파일과 같은 자원에서 특정 부분을 가리키기 위해 사용되며 (#)을 붙여 표현한다. \n\n- 현재 글의 `fragment` 부분을 표현한다면, https://bjcho0501.github.io/DNS/#fragment 와 같다.\n\n### URN(Uniform Resource Name)\nURN은 자원에 고유한 이름을 붙여 식별하는 방식이다. URL같은 경우 위치를 기반으로 식별하기 때문에 자원의 위치가 바뀐다면 식별할 수 없는 단점이 있다. 반면 URN은 **자원에 대한 고유한 이름**이 붙기 때문에 자원의 위치와 상관 없이 식별 가능하다는 장점이 있다.\n\n![ISBN이 0451450523인 도서를 나타내는 URN](D_14.png)\n\n하지만 URN의 경우 아직 URL만큼 널리 채택된 방식은 아니기에 오늘날에는 주로 URL이 더 많이 사용된다."},{"excerpt":"TCP는 데이터 송수신 과정에서 신뢰성을 보장하기 위해 오류 제어, 흐름 제어, 혼잡 제어의 기능을 제공한다.  오류 제어: 재선송 기법 TCP는 신뢰성 있는 통신을 위해 오류를 감지하고, 오류를 감지한 세그먼트를 재전송하는 방법을 사용한다.  먼저, TCP가 오류를 감지하는 방법을 알아보자. TCP의 오류 감지 1. 중복된 ACK 세그먼트를 수신했을 때…","fields":{"slug":"/TCPControl/"},"frontmatter":{"date":"May 21, 2025","title":"TCP의 오류・흐름・혼잡 제어","tags":["Network","TCP","전송계층"]},"rawMarkdownBody":"TCP는 데이터 송수신 과정에서 신뢰성을 보장하기 위해 오류 제어, 흐름 제어, 혼잡 제어의 기능을 제공한다. \n## 오류 제어: 재선송 기법\nTCP는 신뢰성 있는 통신을 위해 오류를 감지하고, 오류를 감지한 세그먼트를 재전송하는 방법을 사용한다. \n\n먼저, TCP가 오류를 감지하는 방법을 알아보자.\n### TCP의 오류 감지\n#### 1. 중복된 ACK 세그먼트를 수신했을 때\n중복된 ACK라는 의미가 애매할 수 있는데, 다음 그림과 함께 이해해보자.\n![수신 호스트 측이 받는 세그먼트의 순서 번호중 일부가 누락된 경우](TC_1.png)\n위 그림처럼 만약 `n+1 세그먼트`가 손실된 상황이라면, ACK를 보내는 호스트는 `n+1 세그먼트`를 받지 못해 `n+1 세그먼트`에 대한 ACK를 2번 보내게 된다. 이럴때 호스트 A의 입장에서는 `n+1 세그먼트`에 대한 ACK를 **중복하여 두번** 받았으므로 `n+1 세그먼트`에 오류가 있음을 감지할 수 있는 것이다.\n\n#### 2. 타임아웃이 발생했을 때\n![송신중인 세그먼트가 누락되어 타임아웃이 발생한 경우](TC_2.png)\n**타임아웃이**란 이름 그대로 정해진 시간 내에 응답을 받지 못하는 상황을 의미한다. TCP 세그먼트를 송신하는 호스트는 모두 **재전송 타이머**라는 값을 유지하는데, 이 타이머의 카운터가 끝나는 상황까지 ACK를 받지 못했다면 오류라 판단한다.\n\n### ARQ: 재전송 기법\n오류를 감지 했다면, 오류를 해결하기 위한 기능을 동작해야 하는데 TCP에서는 재전송 기법을 사용한다. 여기서 수신 호스트의 답변(ACK)과 타임아웃 발생을 토대로 문제를 진단하고, 문제가 생긴 메시지를 재전송함으로써 신뢰성을 확보하는 방식을 **ARQ(Automatic Repeat Request, 자동 재전송 요구)** 라고 한다.\n\n이 ARQ에는 크게 3가지 종류가 있다.\n- Stop-and-Wait ARQ\n- Go-Back-N ARQ\n- Selective Repeat ARQ\n\n### Stop-and-Wait ARQ\n가장 단순하면서 직관적인 재전송 기법이다. 이름 그대로 세그먼트를 송신한 후 제대로 전달 받았음을 확인하기 까지 기다리는 방식이다. 단순하지만, 높은 신뢰성을 보장하는 방식이라 할 수 있다.\n![Stop-and-Wait ARQ 흐름도](TC_3.png)\n하지만, 이러한 방식은 네트워크의 이용 효율이 낮아질 수 있으며 성능 저하로 이어질 수 있기 때문에 오늘날의 인터넷 환경의 TCP에서는 잘 사용하지 않는 방식이다.\n\n### Go-Back-N ARQ\nStop-and-Wait ARQ의 문제를 해결하기 위해서는 각 세그먼트의 응답이 돌아오기 전에 일정한 개수의 세그먼트를 더 보낼 수 있어야 한다. 그래서 **Go-Back-N ARQ**방식은 연속해서 메시지를 전송할 수 있는 기술을 사용하고 있다. 이러한 연속해서 메시지를 전송하는 기술을 **파이프라이닝**이라고 한다.\n\nGo-Back-N ARQ방식은 파이프라이닝 방식을 사용하려 여러 세그먼트를 전송하고, 도중 잘못 전송된 세그먼트가 발생하면 **해당 세그먼트부터 전부 다시 전송**하는 방식이다. \n![Go-Back-N ARQ 흐름도](TC_4.png)\n수신받는 호스트(호스트 B)는 수신받지 못한 세그먼트(n + 2 세그먼트)가 있을 경우, 다른 세그먼트(n + 3 세그먼트)들을 정상적으로 수신 받더라도 수신받지 못한 세그먼트 이외의 모든 세그먼트를 폐기한다. 송신 호스트(호스트 A)에서는 ACK를 받지 못해 타임아웃이 발생하며 잘못된 세그먼트부터 다시 전송하게 되는 것이다.\n\nGo-Back-N ARQ의 확인응답(ACK)은 n번까지의 확인 응답을 누적해가며 보내기 때문에 **누적 확인 응답(CACK)** 이라고 한다.\n\n### Selective Repeat ARQ\nSelective Repeat ARQ의 이름대로 **\"선택적으로 재전송\"** 을 하는 방법이다.\n\n앞서 설명한 Go-Back-N ARQ 방식에서는 한 세그먼트에만 문제가 발생하여도 그 후의 모든 세그먼트를 다시 재전송 하는 단점이 있는 반면, Selective Repeat ARQ 방식에서는 수신 호스트 측에서 제대로 전송받은 **각각의 패킷들에 대해 ACK** 세그먼트를 보내어 문제가 있는 세그먼트만 재전송 하는 방식이다.\n![Selective Repeat ARQ 흐름도](TC_5.png)\n각각 패킷의 ACK를 보낸다는 점에서 Selective Repeat ARQ의 ACK는 **개별 응답 확인**이라고 한다.\n\n오늘날 대부분의 호스트는 TCP 통신에서 **Selective Repeat ARQ**를 지원하며, **Selective Repeat ARQ**가 지원되지 않는 호스트의 경우 **Go-Back-N ARQ** 방식으로 동작한다.\n\n## 흐름 제어: 슬라이딩 윈도우\n오류 제어 기법중 바이프라이닝 기반의 재전송 방식이 정상적으로 동작하려면, 호스트가 한 번에 받아 처리할 수 있는 세그먼트의 양이 정해져 있기 때문에 흐름 제어를 반드시 고려해야 한다. \n\n- `수신 버퍼`: 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 전에 임시로 저장되는 공간\n- `버퍼 오버플로`: 수신 버퍼 크기보다 많은 데이터가 전송되어 세그먼트가 처리되지 못하는 상황\n\n**흐름 제어**는 위와 같은 수신 버퍼의 오버플로를 방지하기 위해 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 유지하는 것을 의미한다. 대표적인 방법으로 **슬라이딩 윈도우**를 사용한다.\n\n슬라이딩 윈도우란, **윈도우**라는 송신 호스트가 파이프라이닝 할 수 있는 최대량을 정해두고 이를 이동시키며 흐름을 제어하는 방식이다.\n![윈도우가 4인 상태의 초기 상태,](TC_7.png)\n위 사진은 윈도우 크기가 4인 상태의 슬라이딩 윈도우 초기 상태이다. 해당 상태에서는 첫 번째 ~ 네 번째 세그먼트만 동시에 보낼 수 있다.\n\n![첫 번째 세그먼트의 ACK를 받은 상태](TC_8.png)\n이 후, 만약 첫 번째 세그먼트의 ACK를 받았다면, 윈도우는 다음 세그먼트의 방향(그림에서는 오른쪽)으로 이동하여 다른 세그먼트를 범위에 포함시킨다.\n\n![두 번째 세그먼트의 ACK를 받은 상태](TC_9.png)\n위 과정을 반복하며 윈도우가 마지막 세그먼트까지 이동하여 송수신의 흐름을 제어한다.\n\n송신 호스트 뿐만 아니라 수신 호스트도 윈도우를 고려하며, 두 호스트의 윈도우 크기는 수신 호스트에서 TCP 세그먼트의 **윈도우 필드**를 통해 공유한다.\n![수신 호스트에서는 TCP의 윈도우 필드를 통해 윈도우 크기를 공유한다](TC_10.png)\n\n결과적으로 송신 호스트는 송신하는 세그먼트를 기준으로 윈도우를 이동시키며 혼잡 제어를 진행하고, 수신 호스트는 수신 받은 세그먼트를 기준으로 윈도우를 이동시키며 혼잡 제어를 진행한다.\n![송수신 호스트의 슬라이딩 윈도우](TC_11.png)\n\n## 혼잡 제어\nTCP에서는 혼잡 제어를 위해 **혼잡 윈도우**의 크기를 계산하는 알고리즘을 가지고 있다. 이러한 알고리즘을 **AIMD**라고 한다.\n\n`혼잡 윈도우` - 혼잡 없이 전송할 수 있을 법한 데이터의 양\n\nAIMD는 Additive Increase/Multiplicative Decrease의 약자로, \"합으로 증가, 곱으로 감소\"라는 의미이다. 혼잡이 감지되지 않는다면 혼잡 윈도우를 *RTT* 마다 1씩 선형적으로 증가시키고, 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 동작을 반복하는 알고리즘이다.\n![혼잡 윈도우는 톱니 모양으로 변화한다](TC_12.png)\n\n> #### RTT\n>RTT(Round Trip Time)란 메시지를 전송한 뒤 그에 대한 답변을 받는 데까지 걸리는 시간을 의미한다.\n>![RTT](TC_6.png)\n\nAIMD로는 완벽한 혼잡 제어가 불가능 하기 때문에, 이를 보조할 혼잡 제어 알고리즘들이 있다.\n1. 느린 시작\n2. 혼잡 회피\n3. 빠른 회복\n\n### 느린 시작 알고리즘\n느린 시작 알고리즘은 혼잡 윈도우를 1부터 시작하여 문제없이 수신된 ACK 세그먼트 하나당 1씩 증가시키는 방식이다.\n\n아래 그림과 같이 RTT마다 2배씩 증가하며, 이는 AIDM에서의 혼잡 윈도우 증가 속도보다 빠르다는 것을 알 수 있다.\n![1이였던 혼잡 윈도우는 최종적으로 8이 되었다](TC_13.png)\n\n하지만, 매번 2배씩 혼잡 윈도우를 증가시킨다면 언젠가는 혼잡 상황을 마주할 확률이 높아지므로 **느린 시작 임계치** 값을 설정하여 이를 방지한다. \n\n아래는 상황별 혼잡을 피하는 방법에 대한 표이다.\n![](TC_14.png)\n### 혼잡 회피 알고리즘\n혼잡 회피 알고리즘은 RTT마다 혼잡 윈도우를 1MSS씩 증가시키는 알고리즘이다. \n\n이름 그대로 혼잡을 회피하기 위해 **느린 시작 임계치를 넘어선 후**, 선형적으로 혼잡 윈도우를 증가시키는 방법이다. \n![느린 시작 임계치 넘음 -> 혼잡 회피](TC_15.png)\n혼잡 회피 도중 타임아웃이 발생하면 혼잡 윈도우 값은 1로, 느린 시작 임계치는 혼잡이 감지된 시점의 혼잡 윈도우 값의 절반으로 초기환 한 뒤 다시 느린 시작을 수행한다. 그리고 혼잡 회피 도중 세 번의 중복 ACK 세그먼트가 발생되었을 때는 혼잡 윈도우 값과 느린 시작 임계치를 대략 절반으로 떨어뜨린 뒤 빠른 알고리즘을 수행한다. \n### 빠른 회복 알고리즘\n빠른 회복 알고리즘은 세 번의 중복 ACK 세그먼트를 수신했을 때 느린 시작은 건너뛰고 혼잡 회피를 수행하는 알고리즘으로, 빠르게 전송률을 회복하기 위한 알고리즘이다.\n\n세 번의 중복된 ACK 세그먼트를 수신하면 빠른 재전송 후 빠른 회복 알고리즘이 수행된다. 단, 빠른 회복 도중이라도 타임아웃이 발생하면 혼잡 윈도우 크기는 1로, 느린 시작 임계치는 혼잡이 감지된 시점의 절반으로 떨어뜨린 후 다시 느린 시작을 수행한다.\n\n아래 그림은 지금까지의 혼잡 알고리즘을 정리한 그림이다.\n![](TC_16.png)"},{"excerpt":"TCP와 UDP는 전송 계층에서 가장 중요한 프로토콜이다. TCP는 신뢰할 수 있는 통신을 위한 연결형 프로토콜이고, UDP는 TCP 보다는 신뢰성이 떨어지지만 비교적 빠른 통신이 가능한 비연결형 프로토콜이다. TCP 통신 단계와 세그먼트 구조 \nTCP 통신은 크게 세 단계로 나눌 수 있다. 통신하기 전에 연결을 수립하고 데이터 송수신 과정에서 재전송을 …","fields":{"slug":"/TCPAndUDP/"},"frontmatter":{"date":"May 13, 2025","title":"TCP와 UDP","tags":["Network","TCP","UDP"]},"rawMarkdownBody":"TCP와 UDP는 전송 계층에서 가장 중요한 프로토콜이다. TCP는 신뢰할 수 있는 통신을 위한 연결형 프로토콜이고, UDP는 TCP 보다는 신뢰성이 떨어지지만 비교적 빠른 통신이 가능한 비연결형 프로토콜이다.\n\n## TCP 통신 단계와 세그먼트 구조\n![TCP 통신의 세 단계](TU_1.png)\nTCP 통신은 크게 세 단계로 나눌 수 있다.\n1. 통신하기 전에 연결을 수립하고\n2. 데이터 송수신 과정에서 재전송을 통한 오류 제어, 흐름 제어, 혼잡 제어 등의 기능을 제공하며\n3. 통신이 끝나면 연결을 종료한다.\n\n이번 포스트에는 1, 3번의 연결 수립과 종료를 먼저 살펴볼 것이다.\n\n### MSS와 TCP의 세그먼트 구조\nTCP의 연결 수립과 종료를 이해하려면 MSS라는 단위와 TCP의 세그먼트 구조를 이해해야 한다.\n\n**MSS**는 **Maximum Segment Size**의 약자로 TCP로 전송할 수 있는 최대 페이로드 크기를 의미한다. MSS의 크기는 MTU와는 다르게 TCP 헤더 크기는 제외한다.\n![MTU는 헤더를 포함한 단위, MSS는 페이로드의 크기](TU_2.png)\n\nTCP의 세그먼트는 아래와 같은 구조로 이루어져 있다.\n![TCP 세그먼트 구조](TU_3.png)\n\n이중 중요한 부분만 살펴보자.\n- **송신지 포트와 수신지 포트**: 송신지 또는 수신지 애플리케이션을 식별하는 포트 번호가 명시된다.\n- **순서번호**: 송수신되는 세그먼트의 올바른 순서를 보장하기 위해 세그먼트 데이터의 첫 바이트에 부여되는 번호이다.\n- **확인 응답 번호**: 상대 호스트가 보낸 세그먼트에 대한 응답으로, 다음으로 수신하기를 기대하는 순서 번호가 명시된다.\n- **제어 비트**: 현재 세그먼트에 대한 부가 정보를 나타낸다. 플래그 비트(flag bits)라고도 불린다.\n- **윈도우**: 수신 윈도우의 크기가 명시된다. 수신 윈도우란 한 번에 수신하고자 하는 데이터의 양을 나타낸다.\n\n이중 제어 비트, 순서번호와 확인 응답 번호를 자세히 알아보자.\n\n### 제어 비트\n제어 비트 필드는 기본적으로 8비트로 구성된다. 각각 자리의 비트는 다른 의미를 가지는데, 이중 TCP의 기본 동작에 대해 논할때 자주 언급되는 비트는 다음과 같다.\n- **ACK**: 세그먼트의 승인을 나타내기 위한 비트\n- **SYN**: 연결을 수립하기 위한 비트\n- **FIN**: 연결을 종료하기 위한 비트\n\n각각의 비트들이 1이 되었을 때를 **'ACK 세그먼트'**, **'SYN 세그먼트'**, **'FIN 세그먼트'** 라 줄여 칭하는 경우가 많다.\n\n### 순서 번호와 확인 응답 번호\n순서 번호 필드와 확인 응답 번호 필드는 TCP의 신뢰성을 보장하기 위한 중요한 필드로, 이 둘을 묶어 생각하는 것이 좋다.\n\n#### 순서 번호\n순서 번호는 세그먼트의 올바른 송수신 순서를 보장하기 위한 번호로, 세그먼트 데이터의 첫 바이트에 부여되는 번호이다. \n\n예를들어 응용 계층에서 전달받은 전송할 데이터가 1900바이트이고 MSS(전송할 데이터의 최대 크기)가 500바이트라 가정한다면, 아래와 같이 4개의 세크먼트 조각이 나올 것이다. \n![500바이트 3개, 400바이트 1개 총 4개의 세그먼트](TU_4.png)\n\n이중 처음 세그먼트 A의 값이 100이라 가정한 후 전송을 진행한다면, 각각의 세그먼트의 순서 번호는 **`세그먼트 A의 순서번호 + 지금까지 송신한 바이트 수`**가 된다.\n\n여기서 처음 세그먼트인 세그먼트 A의 순서 번호를 **초기 순서 번호**라 하며, 각 세그먼트의 순서 번호는 아래의 식과 같다. \n\n$$\n초기\\;세그먼트\\;번호 + 송신한\\;바이트\\;수\n$$\n![초기 세그먼트 번호 100, 각 세그먼트의 순서 번호는 100 + 앞에 송신한 세그먼트 바이트 수의 합](TU_5.png)\n\n#### 확인 응답 번호\n확인 응답 번호는 순서 번호에 대한 응답 번호이다. 수신지가 다음으로 받기를 기대하는 순서 번호가 들어 있으며, 일반적으로 **`수신한 순서 번호 + 1`** 로 설정된다. 확인 응답 번호 값을 보내기 위해서는 제어 비트의 **ACK 세그먼트는 1로 설정**해야 한다. \n\n만약 들어온 호스트의 순서 번호가 8000인 세그먼트를 성공적으로 수신했다면, 수신한 호스트는 ACK 플래그를 1로 설정하고 확인 응답 번호로 8001을 명시한 세그먼드를 전송하게 된다.\n\n![8000인 순서 번호는 8001의 확인 응답 번호 송신해야 한다](TU_6.png)\n\n## TCP 연결 수립과 종료\n### 연결 수립: 쓰리 웨이 핸드셰이크\nTCP의 연결 수립은 쓰리 웨이 핸드셰이크를 통해 이루어진다. 이름 그대로 세 개의 단계로 이루어진 TCP의 연결 수립 과정을 의미한다. \n![](TU_8.png)\n![쓰리 웨이 핸드셰이크 표](TU_7.png)\n처음 연결을 시작하는 호스트의 동작을 **액티브 오픈**이라 하며, 액티브 오픈은 주로 클라이언트에 의해 수행된다. 반대로 연결 요청을 받고 요청에 따라 연결을 수립하는 호스트의 동작을 **패시브 오픈**이라고 하며, 주로 서버에 의해 수행된다.\n\n### 연결 종료\nTCP에서 연결을 수립하고 데이터 송수신이 끝났다면, 이제 연결을 종료해야 한다. \n\n연결을 종료할 때에는 송수신 호스트가 각각 한번씩 FIN과 ACK를 주고 받으며 이루어 진다. \n![](TU_9.png)\n![](TU_10.png)\n액티브 오픈과 패시브 오픈과 같이 연결을 종료할 때에도 액티브 클로즈와 패시브 클로즈가 있다. 연결을 종료하려는 호스트에서 수행되는 동작을 **액티브 클로즈**, 연결 종료 요청을 받아들이는 호스트의 동작을 **패시브 클로즈**라 한다.\n\n## TCP 상태\n연결형 통신과 신뢰할 수 있는 통신을 유지하기 위해 TCP는 현재 어떤 통신 과정에 있는지를 **상태(state)** 정보로 나타낸다. 이러한 점에서 TCP를 **스테이트풀(stateful) 프로토콜**이라고 부른다.\n\nTCP는 많은 종류의 상태를 나타낼 수 있는데, 각각의 상태를 세 종류로 분류하면 다음과 같다.\n1. 연결이 수립되지 않는 상태\n2. 연결 수립 과정에서 주로 볼 수 있는 상태\n3. 연결 종료 과정에서 주로 볼 수 있는 상태\n\n![TCP 상태 표](TU_11.png)\n\n### 연결이 수립되지 않은 상태\n![연결이 수립되지 않은 상태](TU_12.png)\n주로 `CLOSED`나 `LISTEN` 상태를 유지하고 있다.\n- `CLOSE` - 아무런 연결이 없는 상태\n- `LISTEN` - 일종의 연결 대기 상태. 일반적으로 서버로서 동작하는 **패시브 오픈 호스트**가 이 상태를 유지한다.\n\n### 연결 수립 상태\n![연결 수립 상태](TU_13.png)\n주로 `SYN-SENT`, `SYN-RECEIVED`, `ESTABLISHED` 상태를 볼 수 있다.\n- `SYN-SENT` - 액티브 오픈 호스트가 SYN 세그먼트를 보낸 뒤 그에 대한 응답인 SYN + ACK 세그먼트를 기다리는 상태. 연결 요청을 보낸 뒤 대기하는 상태라고 생각하면 된다.\n- `SYN-RECEIVED` - 패시브 오픈 호스트가 SYN + ACK 세그먼트를 보낸 뒤 그에 대한 ACK 세그먼트를 기다리는 상태\n- `ESTABLISHED` - 연결이 확립되고 데이터를 송수신할 수 있는 상태. 두 호스트가 마지막 ACK 세그먼트를 주고 받으면 이 상태로 접어든다.\n\n### 연결 종료 상태 \n![연결 종료 상태 ](TU_14.png)\n주로 `FIN-WAIT-1`, `CLOSE-WAIT`, `FIN-WAIT-2`, `LAST-ACK`, `TIME-WAIT`, `CLOSE` 상태를 볼 수 있다.\n- `FIN-WAIT-1` - 일반적으로 TCP 연결 종료에 있어 첫 단계이다. FIN 세그먼트로서 연결 종료 요청을 보낸 액티브 클로즈 호스트는 `FIN-WAIT-1` 상태에 접어든다.\n- `CLOSE-WAIT` - 종료 요청인 FIN 세그먼트를 받은 패시브 클로즈 호스트가 그에 대한 응답으로 ACK 세그먼트를 보낸 후 대기하는 상태\n- `FIN-WAIT-2` - 상태 호스트의 FIN 세그먼트를 기다리는 상태. `FIN-WAIT-1` 상태에서 ACK 세그먼트를 받게 되면 `FIN-WAIT-2` 상태가 된다. \n- `LAST-ACK` - `CLOSE-WAIT` 상태에서 FIN 세그먼트를 전송한 뒤 이에 대한 ACK 세그먼트를 기다리는 상태\n- `TIME-WAIT` - 액티브 클로즈 호스트가 FIN 세그먼트를 수신한 뒤, 이에 대한 ACK 세그먼트를 전송한 뒤 접어드는 상태. 패시브 클로즈 호스트가 마지막 ACK 세그먼트를 수신하면 바로 `CLOSED` 상태로 전이하는 반면, `TIME-WAIT` 상태에 접어든 액티브 클로즈 호스트는 일정 시간을 기다린 뒤 `CLOSED` 상태로 전이한다.\n\n> #### TIME-WAIT 상태가 필요한 이유\n> 액티브 클로즈 호스트만 `TIME-WAIT` 상태에서 일정 시간 기다리고 `CLSOE` 상태가 되는 이유는 생대 호스트가 받았어야 할 마지막 ACK 세그먼트의 올바른 전송 유무를 알기 위함이다. \n> \n> 만약 일정 상태를 대기하기 않고 바로 종료한다면, ACK 세그먼트가 올바르게 전송되지 않았을 때 재전송을 할 수 없어짐으로 문제가 발생할 수 있다.\n\n#### CLOSING 상태\n`CLOSING` 상태는 보통 동시에 연결을 종료하려 할 때 전이되는 상태이다. 서로가 FIN 세그먼트를 보내고 받은 뒤 각자 그에 대한 ACK 세그먼트를 보냈지만, 아직 자신의 FIN 세그먼트에 대한 ACK 세그먼트를 받지 못했을 때 접어드는 상태이다. \n\n양쪽 모두 연결 종료를 요정하고, 서로 종료 응답을 기다리는 경우 `CLOSING` 상태에 접어드는 것이다. 이 경우 ACK 세그먼트를 수신한다면 각자 `TIME-WAIT` 상태로 접어든 뒤 종료한다.\n![CLOSING 상태](TU_15.png)\n\n지금까지의 상태를 종합하면 다음과 같다.\n![TCP 상태 종합](TU_16.png)\n\n## UDP 데이터그램 구조\nUDP는 TCP와 달리 비연결형 통신을 수행하는 신뢰할 수 없는 프로토콜이다. 때문에 연결 수립 및 해제, 재전송을 통한 오류 제어, 혼잡 제어, 흐름 제어 등을 수행하지 않는다. 또 TCP 처럼 상태를 유지하지 않기 때문에 **스테이트리스** 프로토콜의 일종이라고도 한다.\n![UDP의 데이터그램 구조](TU_17.png)\nUDP의 데이터그램 구조는 TCP에 비해 상당히 간단한 구조로 구성되어 있다. \n- **송신지 포트**와 **수신지 포트**: 송수진지의 포트 번호가 담긴다.\n- **길이**: 헤더를 포함한 UDP 데이터그램의 바이트가 담긴다.\n- **체크섬**: 데이터그램 전송 과정에서 오류가 발생했는지 검사하기 위한 필드이다. 체크섬은 데이터그램의 훼손 여부를 확인하기 위한 정보일 뿐 신뢰성에는 관련이 없다.\n\n이러한 간단한 구조 덕분에 UDP는 TCP에 비해 빠른 전송이 가능하다. TCP와 UDP의 작동 과정을 그림으로 비교하면 다음과 같다.\n![TCP](TU_18.png)\n![UDP](TU_19.png)\nUDP의 전송 과정은 **\"빠르게 마구 던지기\"** 와 같기 때문에 패킷이 손실되거나 순서가 바뀔 수도 있다."},{"excerpt":"지금까지 IP 주소의 신뢰할 수 없는 전송가 비연결형 전송 특성을 해결하기 위해 전송 계층의 TCP 등을 사용해 온다고 하였는데, 네트워크 계층에서 이 문제를 보완하기 위한 프로토콜로 ICMP가 있다. ICMP 란? Internet Control Message Protocol의 약자로 IP 패킷의 전송 과정에 대한 피드백 메시지를 얻기 위해 사용하는 프토…","fields":{"slug":"/ICMP/"},"frontmatter":{"date":"May 12, 2025","title":"ICMP","tags":["Network"]},"rawMarkdownBody":"지금까지 IP 주소의 신뢰할 수 없는 전송가 비연결형 전송 특성을 해결하기 위해 전송 계층의 TCP 등을 사용해 온다고 하였는데, 네트워크 계층에서 이 문제를 **보완**하기 위한 프로토콜로 **ICMP**가 있다.\n\n## ICMP 란?\n**Internet Control Message Protocol**의 약자로 IP 패킷의 전송 과정에 대한 **피드백 메시지**를 얻기 위해 사용하는 프토콜이다. \n\n피드백 메시지의 종류로는\n1. 전송 과정에서 발생한 문제 상황에 대한 오류 보고\n2. 네트워크에 대한 진단 정보(네트워크상의 정보 제공)\n\n이렇게 2종류가 있다.\n\nICMP의 피드백 메시지는 타입과 코드로 정의되며, 타입과 코드는 ICMP 패킷 헤더에 포함되어 있는 정보이다.\nICMP 패킷 헤더의 타입 필드에는 ICMP 메시지의 **유형이 번호**로 명시되고, 코드 필드에는 **구체적인 메시지 내용이 번호**로 명시된다.\n\n![타입 + 코드로 이루어져 있다](IC_1.png)\n\n만약 패킷의 TTL 필드가 0이 되면 라우터는 송신지 호스트에 `시간 초과 타입 - TTL 만료 코드`가 담긴 ICMP 패킷을 전송한다. \n\n## 네트워크 상의 정보 제공을 위한 ICMP\n![네트워크 상의 정보를 제공하기 위한 목적인 ICMP 메시지](IC_2.png)\n정보 제공을 위한 ICMP는 네트워크상의 간단한 문제 진단 및 테스트를 위해 사용되기도 한다. `ping`이나 `tracert` 같은 명령어들이 ICMP 기반의 명령어들이다. \n\n## ICMP는 신뢰성을 보장하지 못한다\nICMP의 유의할 점은 ICMP 프로토콜이 **IP의 신뢰성을 보장하는 프로토콜이 아니라는 점**이다. ICMP는 그저 IP의 신뢰할 수 없는 특정을 보완하기 위한 **도구** 역할만 할뿐 여전히 IP 패킷이 수신지까지 도착하지 못하거나 ICMP 패킷 자체가 송신지까지 되돌아 오지 못할 수도 있다.\n\n신뢰성을 완전히 보장하기 위해서는 전송 계층의 프로토콜(TCP 등)이 필요하다.\n\n## 정리\n- ICMP은 네트워크 계층에서 IP의 신뢰성 문제를 보완하기 위한 프로토콜이다.\n- `타입(type) + 코드(code)`로 구성된 패킷을 피드백 메시지로 사용하여 동작한다.\n- IP의 신뢰성 문제를 완전히 해결하는 방법은 아니므로 완전한 신뢰성 보장을 위해서는 전송 계층의 프토로콜이 필요하다."},{"excerpt":"포트포워딩이란? 네트워크 내 특정 호스트에 IP 주소와 포트 번호를 미리 할당하고, 해당 로써  해당 호스트에게 패킷을 전달하는 기능이다. 주로 네트워크 외부에서 네트워크 내부로 통신을 시작할 때, 네트워크 내부의 서버를 외부에서 접속할 수 있도록 접속 정보를 공개할 때 사용된다. 네트워크 내부의 여러 호스트가 공인 IP 주소를 공유하는 상황에서 네트워크…","fields":{"slug":"/PortForwarding/"},"frontmatter":{"date":"May 11, 2025","title":"포트포워딩","tags":["Network"]},"rawMarkdownBody":"\n## 포트포워딩이란?\n네트워크 내 특정 호스트에 **IP 주소와 포트 번호를 미리 할당**하고, 해당 `IP 주소:포트 번호`로써  해당 호스트에게 패킷을 전달하는 기능이다. 주로 **네트워크 외부**에서 **네트워크 내부로 통신을 시작**할 때, 네트워크 내부의 서버를 외부에서 접속할 수 있도록 접속 정보를 공개할 때 사용된다.\n\n네트워크 내부의 여러 호스트가 공인 IP 주소를 공유하는 상황에서 네트워크 외부의 호스트가 특정 호스트에 패킷을 전달해야 할 때, 공인 IP를 사용하는 외부 호스트에서 보낸 패킷을 어떤 `사설 IP 주소:포트 번호`로 전송해야 할지 알 수 없는 상황에서 포트포워딩을 사용할 수 있다.\n![네트워크 외부 호스트는 어떤 호스트로 수신해야 할지 알 수 없다](PF_1.png)\n\n특정 IP 주소와 포트 번호 쌍을 특정 호스트에게 할당한 뒤, 외부에서 통신을 시작할 호스트에게 해당 접속 정보를 알려주면 통신이 가능하게 된다. \n\n아래 사진은 실제 포트포워딩 설정 화면이다. 어떤 공인 `IP 주소:외부 접속 포트(서비스 포트)`에 접근했을 때 어떤 `사설 IP 주소:내부 전달 포트`로 전달할지를 설정할 수 있다. \n![공인 IP 주소:1234로 전송된 패킷은 192.168.100.100:1025로 전달된다](PF_2.png)\n\n## 정리\n- 포트포워딩은 네트워크 외부에서 내부로 통신할 때, IP주소와 포트 번호를 할당하여 외부에서 접근이 가능하도록 하는 기술이다.\n- `공인 IP 주소: 포트번호`로 오는 패킷의 **포트 번호**와 네트워크 내부의 **`사설 IP 주소: 포트번호`**를 사용하여 패킷을 네트워크 내부 호스트로 보낸다.\n- 주로 웹 서버, FTP 서버, 게임 서버 등에 사용된다."},{"excerpt":"NAT이란 사설 IP 주소를 공인 IP 주소로 변환하는 기술이다. IP 변환을 위해 NAT은 NAT 변환 테이블을 사용한다. NAT 변환 테이블 NAT 테이블은 네트워크 외부 IP와 내부 IP가 쌍으로 명시되어 있는 구조이다. 명시되어 있는 주소를 활용하며 네트워크 내부에서 네트워크 내부로 송신을 할 때 송신지 수소가 공인 IP로 변환되고 반대로 네트워크…","fields":{"slug":"/PortNAT/"},"frontmatter":{"date":"May 10, 2025","title":"포트 기반 NAT","tags":["NAT","Network","전송계층"]},"rawMarkdownBody":"NAT이란 사설 IP 주소를 공인 IP 주소로 변환하는 기술이다. IP 변환을 위해 NAT은 **NAT 변환 테이블**을 사용한다.\n\n## NAT 변환 테이블\nNAT 테이블은 네트워크 외부 IP와 내부 IP가 쌍으로 명시되어 있는 구조이다. 명시되어 있는 주소를 활용하며 네트워크 내부에서 네트워크 내부로 송신을 할 때 송신지 수소가 공인 IP로 변환되고 반대로 네트워크 외부에서 송신될 때는 송신지 주소가 사설 IP로 변환되는 과정을 거친다.\n![송신지 주소와 수신지 주소의 변환을 NAT에서 담당한다](NT_1.png)\n\n하지만 위와 같은 방식으로 NAT이 작동한다면, 사설 IP와 공인 IP가 `1:1`로 대응되어야 한다. 즉 사설 IP의 개수만큼 공인 IP가 필요해 진다는 것이다. 이러면 NAT을 사용할 때와 사용하지 않을 때의 공인 IP 수가 같으므로 사설 IP와 공인 IP가 `1:n`의 관계가 되도록 해야한다. 이를 위해 포토가 사용된다.\n\n## NAPT\n포트 기반 NAT를 **NAPT(Network Address Port Translation)** 혹은 **APT(Address Port Translation)** 이라고 한다. NAPT는 포트를 활용하여 하나의 공인 IP 주소를 여러 사설 IP 주소가 공유할 수 있도록 한다.\n\nNAT 테이블에 변환할 IP 주소 쌍과 함께 포트 번호도 기록하고 변환하여 하나의 공인 IP로 많은 사설 IP을 변환시키는 것이 가능하다. NAPT의 송수신 과정이 담긴 사진이다.\n![포트가 추가 됨으로 하나의 공인 IP를 여러 사설 IP 변환에 사용 가능해 진다](NT_2.png)\n\n## 정리\n- NAT는 사설 IP를 공인 IP로 변환하는 기술이다. NAT 변환 테이블을 사용하여 변환을 진행한다.\n- 일반 NAT은 사설 IP와 공인 IP를 `1:1`로 사용해야 하기 때문에 IP 부족 문제를 해결할 수 없다.\n- 사설 IP와 공인 IP의 `1:n` 사용을 위한 기술로 포트 정보까지 포함하여 변환하는 NAPT(혹은 APT)기술이 있다."},{"excerpt":"네트워크 계층의 IP는 신뢰할 수 없는 통신과 비 연결형 통신을 수행한다는 한계가 있다. 전송 계층은 신뢰할 수 있는 통신과 연결형 통신을 가능하게 하여 IP의 한계를 극복하고, 포트 번호를 통헤 응용 계층의 애플리케이션 프로세스들을 식별하는 역할을 수행한다. 신뢰할 수 없는 통신과 비연결형 통신 신뢰할 수 없는 통신은 IP 프로토콜이 패킷이 수신지까지 …","fields":{"slug":"/LimitOfIpAndAboutPort/"},"frontmatter":{"date":"May 08, 2025","title":"IP의 한계와 포트","tags":["Network","포트","전송계층"]},"rawMarkdownBody":"네트워크 계층의 IP는 **신뢰할 수 없는 통신**과 **비 연결형 통신**을 수행한다는 한계가 있다. 전송 계층은 신뢰할 수 있는 통신과 연결형 통신을 가능하게 하여 IP의 한계를 극복하고, **포트 번호**를 통헤 응용 계층의 애플리케이션 프로세스들을 식별하는 역할을 수행한다.\n\n## 신뢰할 수 없는 통신과 비연결형 통신\n**신뢰할 수 없는 통신**은 IP 프로토콜이 패킷이 수신지까지 제대로 전송되었는지 보장하지 않는 특징이다. 패킷의 손상이나 손실에 대한 확인을 하지 않으며 도착할 것이라는 보장도 없다는 것이다. 이러한 특성을 **최선형 전달**이라 부른다.\n\n**신뢰할 수 없는 통신**: IP 프로토콜이 전송한 패킷이 수신지까지 전송되었다는 보장을 하지 않는 특징\n\n**최선형 전달**: 전송 결과에 대해서는 어떠한 보장도 하지 않는 특성 (전송은 최선을 다할게~ 근데 결과는 몰라)\n\n**비 연결형 통신**은 이름 그대로 송수신 호스트 간에 사전 연결 수립 작업을 가치지 않는 특징을 의미한다.\n\n## 전송 계층이 IP의 한계를 보완하는 방법\n### 1. 전송 계층은 연결형 통신을 가능하게 한다.\n연결형 통신을 지원하는 프로토콜인 **TCP**를 사용하여 두 호스트가 정보를 주고 받기 전에 마치 가상의 회선을 설정하듯 연결을 수립한다.\n\n### 2. 전송 계층은 신뢰성 있는 통신을 가능하게 한다.\n이 또한 **TCP**를 사용하여 패킷의 확실한 전달을 보장하기 위해 재전송을 통신 오류 제어, 흐름 제어, 혼잡 제어 등을 진행한다.\n\n> #### 빠른 전송을 위한 프로토콜, UDP\n> 패킷 전송에 있어, 신뢰성 있는 통신을 중요하게 여기는 통신에서는 TCP를 사용하지만, 패킷의 일부 손실 보단 속도가 중요한 상황(실시간 스트리밍 서비스 등)에서는 비연결성 통신과 신뢰할 수 없는 통신을 해야 할 때가 있다. 이럴때 사용하는 프토로콜이 **UDP** 이다.\n\n\n## 응용 계층과의 연결 다리, 포트\n### 포트의 정의 \n패킷이 실행 중인 특정 애플리케이션 프로세스까지 전달되어야 할때, 특정 애플리케이션을 식별할 수 있는 정보를 **포트**라고 한다.\n\n![웹 브라우저, 게임, 메신저라는 프로세스의 패킷 송수신을 위해선 포트가 필요하다](IPPR_1.png)\n\n### 포트의 분류\n전송 계층에서는 수신자 포트와 송신자 포트를 통해 송수신지 호스트의 애플리케이션을 식별한다. 포트 번호는 2^16(65536개, 0 ~ 65535)개가 존재히며, 포트의 범위별 대표적인 종류는 3가지가 있다.\n\n![포트 종류와 포트 번호 범위](IPPR_2.png)\n\n> 잘 알려진 포트와 등록된 포트의 할당은 **인터넷 할당 번호 관리 기관(IANA)** 에서 한다. 물론 해당 포트 번호는 권고일뿐 강제는 아니다.\n#### 잘 알려진 포트(well kown port)\n- 0 ~ 1023 포트 번호\n- 시스템 포트라고도 불리며 범용적으로 사용되는 포트 번호를 의미한다. \n#### 등록된 포트(registered port)\n- 1024 ~ 49151 포트 번호\n- 잘 알려진 포트에 비해서느 덜 범용적이지만, 흔히 사용되는 애플리케이션 프로토콜을 할당하기 위해 사용된다.\n#### 동적 포트(dynamic port)\n- 49152 ~ 65535 포트 번호\n- 사설 포트, 임시 포트라고도 불리며 특별히 관리되지 않아 자유롭게 사용 가능한 포트이다.\n\n서버로서 동작하는 프로그램은 일반적으로 잘 알려진 포트, 등록된 포트(사전에 암묵적으로 정해진 포트)로 동작하는 경우가 많다. 하지만 클라이언트로서 동작하는 프로그램은 동적 포트 번호중에서 **임의의 포트가 할당되는 경우가 많다**. 대표적인 예시로 **웹 브라우저**가 있다.\n\n![HTTP 서버는 잘 알려진 포트 번호, 클라이언트는 동적 포트내의 임의 포트번호를 사용하는 것을 볼 수 있다](IPPR_3.png)\n\nIP와 포트 번호에 대한 정보가 함께 주어지면, **특정 호스트에서 실행 중인 특정 애플리케이션 프로세스**를 식별 할 수 있기 때문에, 일반적으로 **IP 주소:포트번호** 형식으로 IP 주소와 함께 표기되는 경우가 많다.\n\n![IP와 포트번호 표기 방법](IPPPR_4.png)\n## 정리\n- 전송 계층은 신뢰할 수 있는 연결형 통신이 가능한 프로토콜인 **TCP**를 제공하여 네트워크 계층의 **한계를 보완**한다.\n- 포트를 통해 응용 계층의 애플리케이션을 식별함으로써 응용 계층과의 연결다리 역할을 수행한다."},{"excerpt":"라우팅은 패킷이 이동할 최적의 경로를 설정한 뒤 해당 경로로 패킷을 이동시키는 것 이다. 라우팅을 위한 네트워크 장비로는 라우터나 L3 스위치가 있다. 라우팅에 관한 내용은 방대하기 때문에 아래 표와 같은 흐름으로 작성할 예정이다.\n 라우터 라우터는 네트워크 계층의 핵심 기능을 담당한다. 앞선 포스트에서의 NAT이나 DHCP 같은 여러 기능을 감소있는 네…","fields":{"slug":"/NetworkRouting/"},"frontmatter":{"date":"May 05, 2025","title":"라우팅","tags":["Network","라우팅"]},"rawMarkdownBody":"\n**라우팅**은 패킷이 이동할 최적의 경로를 설정한 뒤 해당 경로로 패킷을 이동시키는 것 이다. 라우팅을 위한 네트워크 장비로는 **라우터**나 **L3 스위치**가 있다.\n\n라우팅에 관한 내용은 방대하기 때문에 아래 표와 같은 흐름으로 작성할 예정이다.\n![라우팅 학습 표](RO_1.png)\n\n## 라우터\n라우터는 네트워크 계층의 핵심 기능을 담당한다. 앞선 포스트에서의 NAT이나 DHCP 같은 여러 기능을 감소있는 네트워크 장비이다.\n\n라우팅 도중 패킷이 호스트와 라우터 간에, 혹은 라우터와 라우터 간에 이동하는 하나의 과정을 **홉**이라고 부른다.\n\n## 라우팅 테이블\n라우팅 테이블은 라우터가 저장하고 관리하며, 특정 수신지까지 도달하기 위한 정보를 명시한 일종을 표와 같은 정보이다. 라우터는 라우팅 테이블을 참고하여 수신지까지의 도달 경로를 판단한다.\n\n라우팅 테이블에 포함된 정보는 라우팅 방식이나, 호스트의 환경에 따라 다를 수 있지만 아래와 같은 정보들은 공통적으로 포함되어 있다.\n\n- **수신지 IP주소와 서브넷 마스크**\n\t- 최종적으로 패킷을 전달할 대상을 의미한다.\n- **다음 홉**\n\t- 최종 수신지까지 가지 위해 다음으로 거쳐야 할 라우터의 IP 주소이다.\n\t- **게이트웨이**라고 명시되기도 한다.\n- **네트워크 인터페이스**\n\t- 패킷을 네트워크로 내보내는데 사용되는 네트워크 장치이다.\n\t- 인터페이스(NIC) 이름이 직접적으로 명시되거나 인터페이스에 대응하는 IP 주소가 명시되기도 한다.\n- **메트릭**\n\t- 해당 경로로 이동하는 데에 드는 비용을 의미한다. \n\t- 흔히 같은 종류의 물건중 저렴한 물건이 선호되듯, 라우터가 라우팅 테이블에 있는 경로 중 패킷을 내보낼 경로를 선택할 때도 메트릭이 낮은 경로(비용이 적은)를 선호한다.\n\n![수신지가 192.168.2.0/24인 패킷은 eth0(인터페이스)를 통해 192.168.2.1(게이트웨이)로 전송하라](RO_2.png)\n\n### 디폴트 라우트\n패킷에 있는 수신지 IP 주소와 서브넷 마스크가 라우팅 테이블의 정보와 일치할 수도 있겠지만, 그러지 않을 경우 패깃을 보낼 곳이 필요하다. 이를 위해 기본 경로를 설정하여 해당 경로로 패킷을 보내는데, 이 **기본 경로**를 **디폴트 라우트**라고 한다.\n\n디폴트 라우트는 모든 IP 주소를 의미하는 0.0.0.0/0으로 명시한다.\n![192.168.0.1이 기본 게이트웨이가 되는 것이다](RO_3.png)\n\n기본 게이트웨이는 호스트가 속한 네트워크 외부로 나가기 위한 첫번 째 경로이고, 일반적으로 라우터 주소를 의미한다.\n![네트워크 밖으로 나가기 위한 첫걸음이 기본 게이트웨이 이다](RO_4.png)\n\n> #### 게이트웨이? 라우터?\n> 위 글에서 **기본 게이트웨이**와 **라우터**를 비슷한 무언가 처럼 사용하였는데, 이 둘에는 큰 차이가 있다.\n> \n> <br>\n> 라우터는 IP 패킷을 네트워크 간에 전달하는 장비,<br>\n> 게이트웨이는 한 네트워크에서 다른 네트워크로 나가는 출입구를 의미한다.\n> \n> 라우터는 기술적 **장비**를 의미하고, 게이트웨이는 역할 또는 위치인 **개념**을 의미하는 것이다.\n> \n> <br>\n> 따라서, 모든 라우터는 게이트웨이일 수 있지만, 모든 게이트웨이가 반드시 라우터는 아니다.\n\n## 라우팅 테이블을 만드는 방법\n라우팅 테이블은 크게 정적 라우팅, 동적 라우팅 방법을 통해 만들어 진다.\n![](RO_5.png)\n\n### 정적 라우팅\n**정적 라우팅**은 사용자가 수동으로 직접 채워넣은 라우팅 테이블을 토대로 라우팅되는 방식이다. 아래는 라우팅 테이블을 수동으로 입력하는 명령어이다.\n![해당 명령어들이 있다 정도로만 이해하고 넘어가면 된다](RO_6.png)\n\n### 동적 라우팅\n정적 라우팅은 수동으로 직접 라우팅 테이블을 채우는 구조상 수많은 라우팅 정보들을 수동으로 채우는데 한계가 있고, 입력 실수로 인한 문제가 있을 수도 있다. 이를 해결하기 위해 자동으로 라우팅 테이블 항목을 만들고 관리하는 **동적 라우팅** 방식이 있다.\n\n동적 라우팅을 수행하기 위해서는 라우터끼리 서로 자신의 정보를 교환하게 되는데, 이때 사용되는 프로토콜이 **(동적) 라우팅 프로토콜**이다.\n\n## 라우터들의 집단 네트워크, AS\nAS(Autonomous System)는 동일한 라우팅 정책으로 운용되는 라우터들의 집단 네트워크를 의미한다. 한 회사나 단체에서 관리하는 라우터 집단을 AS라 생각해도 좋다.\n\nAS마다 인터넷상에서 고유한 AS번호(ASN, Autonomous System Number)가 할당된다. AS번호는 사설 번호도 있지만, 일반적으로 AS번호를 칭할때는 고유한 번호는 일컫는 경우가 많다.\n\n한 AS 내에는 다수의 라우터가 있으며 라우터들은 AS 내부에서만 통신할 수 있고, AS 외부와 통신할 수도 있다. AS 외부와 통신할 경우 AS 경계에서 통신을 주고 받을 수 있는 AS 경계 라우터(ASBR, Autonomous System Boundary Router)라는 특별한 라우터를 사용한다.\n![AS의 경계에는 ASBR이 있으며, ASBR을 통해 AS 외부와 통신한다](RO_7.png)\n\n## 라우팅 프로토콜\n**라우팅 프로토콜**은 라우터끼리 자신들의 정보를 교환하며 패킷이 이동할 최적의 경로를 찾기 위한 프로토콜이다.\n라우팅 프로토콜은 AS 내부에서 수행되는지, 외부에서 수행되는지에 따라 종류가 나뉜다. 내부에서 수행된다면 **IGP(Inerior Gateway Protocol)** , 외부에서 수행된다면 **EGP(Exterior Gateway Protocol)** 라고 한다.\n![](RO_8.png)\n\n### IGP: RIP와 OSPF\n대표적인 IGP에는 **RIP**와 **OSPF**가 있다. 이 프로토콜들은 최적의 경로를 선정하는 과정에서 **거리 백터**가 사용되느냐, **링크 상태**가 사용되느냐로 구분할 수 있다.\n![](RO_9.png)\n\n#### RIP\nRIP는 거리 백터 기반의 라우팅 프로토콜이다. 거리 백터 라우팅 프로토콜이란 이름 그대로 **거리를 기반으로 최적의 경로를 찾는 라우팅 프로토콜**을 의미한다. 거리는 **홉**을 의미한다.\n\nRIP는 인접한 라우터끼리 경로 정보를 주기적으로 교환하며 라우팅 테이블을 갱신한다. 이를 통해 특정 수신지까지에 도달하기 까지의 홉 수를 할 수 있고, 이 **홉 수가 가장 적은 경로**를 최적의 경로로 판단한다. 홉 수가 적을수록 라우팅 테이블상의 메트릭 값도 작아진다.\n![](RO_10.png)\n\n#### OSPF\nOSPF는 링크 상태 라우팅 프로토콜이다. 네트워크의 현재 상태를 **링크 상태 데이터베이스**에 저장한다. 링크 상태 데이터베이스에는 라우터들의 연결 관계, 연결 비용 등의 현재 네트워크 상태를 그래프로 표현하기 위한 데이터가 저장되어있다. 라우터는 위 데이터를 기반으로 현재 네트워크 구성을 **마치 지도처럼 그린 후** 최적의 경로를 선택한다.\n![](RO_11.png)\n\nOSPF는 최적의 경로를 계산하기 위해 대역폭을 기반으로 메트릭을 계산한다. 대역폭이 높은 링크일수록 메트릭이 낮은 경로로 인식한다. 또 RIP와 달리 네트워크의 구성이 변경되었을 때 라우팅 테이블이 갱신된다.\n\n하지만, 네트워크 구성이 변경될 때마다 테이블이 갱신된다면, 네트워크 규모가 커짐에 따라 부담이 커지게 되는 문제가 있다. 이를 해결하기 위해 OSPF에서는 AS를 **에어리어라**는 단위로 나눈 후 해당 에어리어 내에서만 링크 상태를 공유한다. 에어리어 간의 경계에서 연결을 담당하는 라우터는 **ABR(Area Border Router)** 이라고 한다.\n![OSPF의 에이리어](RO_12.png)\n\n### EGP: BGP\n대표적인 EGP로는 **BGP(Border Gatway Protocol)** 이 있다. BFP는 AS간 통신 뿐만 아니라 AS내의 통신도 가능한데, 각각 eEGP와 iEGP라고 불린다.\n\n#### BGP\nAS간의 정보를 주고 받기 위해서는 BGP를 사용하는 라우터가 AS안에 하나 이상 있어야 하며 또 다른 AS의 BGP를 사용하는 라우터와 연결되어야 한다. 이 연결은 BGP 메시지를 주고 받음으로써 이루어 지며, BGP 메시지를 주고 받을 수 있도록 연결된 라우터를 **피어(peer)** 라고 정의 한다. 그리고 피어 관계가 되도록 하는 과정을 **피어링(peering)** 이라고 한다.\n![BGP의 피어링](RO_13.png)\n\nBGP는 RIP와 OSPF에 비해 최적의 경로를 경정하는 과정이 복잡하고, 일정하지 않다. 왜냐하면, 경로를 결정하는 과정에서 수진지 주소와 더불어 다양한 **\"속성\"과 \"정책\"**이 고려되기 때문이다.\n\n속성이란 경로에 대한 일종의 부가 정보이다. 대표적인 속성으로는 아래와 같은 속성들이 있다.\n\n- **AS-PATH 속성**: 메시지가 수신지에 이르는 과정에서 통과하는 AS들의 목록\n- **NEXT-HOP 속성**: 다음 홉, 다음으로 거칠 라우터의 IP 주소\n- **LOCAL-PREF 속성**: 지역 선호도, AS 외부 경로에 있어 AS 내부에서 어떤 경로를 선호할지에 대한 척도\n\n![](RO_14.png)"},{"excerpt":"IP 주소는 네트워크 통신에서 기본적으로 사용되는 주소이다. 하나의 IP 주소는 크게 네크워크 주소와 호스트 주소로 이루어져 있다. 네트워크 주소와 호스트 주소 네트워크 주소는 네트워크 ID, 네트워크 식별자 등으로 부르기도 하며, 호스트 주소는 호스트 ID, 호스트 식별자등으로 부른다.  네트워크 주소와 호스트 주소의 범위는 유동적일 수 있다. 이런 유…","fields":{"slug":"/NetworkIPAddress/"},"frontmatter":{"date":"May 01, 2025","title":"IP 주소","tags":["Network","IP-주소"]},"rawMarkdownBody":"IP 주소는 네트워크 통신에서 기본적으로 사용되는 주소이다. 하나의 IP 주소는 크게 **네크워크 주소**와 **호스트 주소**로 이루어져 있다.\n\n## 네트워크 주소와 호스트 주소\n**네트워크 주소**는 네트워크 ID, 네트워크 식별자 등으로 부르기도 하며, **호스트 주소**는 호스트 ID, 호스트 식별자등으로 부른다.\n\n![네트워크 주소는 호스트가 속한 특정 네트워크를 식별, 호스트 주소는 특정 호스트를 식별](IP_1.png)\n\n네트워크 주소와 호스트 주소의 범위는 유동적일 수 있다. 이런 유동적인 네트워크 주소와 호스트 주소를 분류하는 기준이 IP 주소의 **클래스**이다.\n\n## 클래스풀 주소 체계\n**클래스**는 네트워크 크기에 따라 IP 주소를 분류하는 기준이다. 클래스를 이용하면 필요한 호스트 IP 개수에 따라 네트워크 크기를 가변적으로 조정해 네트워크 주소와 호스트 주소를 구획할 수 있다.\n\n이처럼, 클래스를 기반으로 IP 주소를 관리하는 주소 체계를 **클래스풀 주소 체계**라고 한다. **클래스풀 주소 체계**에는 각각 A, B, C, D, E 클래스가 있다. 이중 D, E 클래스는 각각 멀티캐스트를 위한 클래스와 특수한 목적을 위해 예약된 클래스이기 때문에 A, B, C 클래스만 살펴볼 것이다.\n### A 클래스\n- 할당 가능한 호스트 주소가 3옥텟으로 가장 많다. (2^24, 16,777,216개)\n- 네트워크 주소는 1옥텟으로 비트 '0'으로 시작한다. (2^7, 128개)\n- 최솟값: 0.0.0.0, 최댓값: 127.255.255.255\n\n![A 클래스](IP_A.png)\n\n### B 클래스\n- 할당 가능한 호스트 주소가 2옥텟 (2^16, 65,534개)\n- 네트워크 주소는 2옥텟으로 비트 '10'으로 시작한다. (2^14, 16,384개)\n- 최솟값: 128.0.0.0, 최댓값: 191.255.255.255\n\n![B 클래스](IP_B.png)\n\n### C 클래스\n- 할당 가능한 호스트 주소가 1옥텟 (2^8, 256개)\n- 네트워크 주소는 3옥텟으로 비트 '110'으로 시작한다. (2^21, 2,097,152개)\n- 최솟값: 192.0.0.0, 최댓값: 223.255.255.255\n\n![C 클래스](IP_C.png)\n\n> **할당 가능한 호스트의 개수에 따른 순서**\n> \n> A클래스 > B클래스 > C클래스\n\n### 이미 예약된 호스트 주소 공간\n호스트 주소가 전부 0인 IP주소와 호스트 주소가 전부 1인 IP 주소는 특정 호스트를 지칭하는 IP 주소로 활용할 수 없다. 호스트 주소가 전부 0인 IP 주소는 **해당 네트워크 자체를 의미하는 네트워크 주소**로, 전부 1인 IP 주소는 **브로드캐스트를 위한 주소**로 사용되기 때문이다.\n\n![](IP_2.png)\n\n때문에 실제로 할당할 수 있는 IP 주소의 개수는 이론상 할당 가능한 개수에서 2를 뺀 개수이다. A 클래스를 예로 들면 아래와 같다고 할 수 있다.\n$$2^{24}-2(16,777,216 - 2개)$$\n![](IP_3.png)\n\n## 클래스리스 주소 체계\n클래스리스 주소 체계는 클래스풀 주소 체계의 유동적이지 못해 생기는 한계를 해결하기 위한 체계이다. 이름처럼 클래스 개념 없이 클래스에 구애받지 않고 네트워크 영역을 나누어서 호스트에게 IP 주소 공간을 할당하는 방식이다.\n#### 서브넷 마스크\n클래스리스 주소 체계는 클래스를 이용하지 않아 IP 주소상에서 네트워크 주소와 호스트 주소를 구분 짓는 지점은 임의의 지점이 될 수 있다. 이러한 임의의 지점을 표시하는 방법이 서브넷 마스크이다.\n\n**서브넷 마스크**는 IP 주소상의 네트워크 주소는 1, 호스트 주소는 0으로 표기한 비트열을 의미한다. 그리고 이 서버넷 마스크를 사용해 클래스는 원하는 크기로 쪼개어 사용하는 것을 **서브네팅**이라고 한다.\n\n### 서브네팅: 비트 AND 연산\n서브넷 마스크를 사용하여 네트워크 주소와 호스트 주소는 구분 짓는 방법은 **비트 AND 연산**을 사용하여 구할 수 있다.\n![비트 AND 연산](IP_4.png)\n\n해당 연산을 IP주소와 서브넷 마스크에 해주면 해당 IP 주소의 네트워크 주소를 연산 결과로 얻을 수 있다.\n![IP 주소와 서브넷 마스크를 비트로 바꾼다](IP_5.png)\n![그 후 비트 AND 연산을 해준다](IP_6.png)\n\n해당 결과의 호스트 주소 부분이 모두 0인 `192.168.219.0`은 네트워크 주소, 모두 1인 `192.168.219.255`는 브로드캐스트 주소임으로 이를 제외한 `192.168.219.1` ~ `192.168.219.254` 즉 254개의 주소가 실제 사용가능한 주소가 된다.\n\n### 서브넷 마스크 표기: CIDR 표기법\n서브넷 마스크를 표기하는 방법중 CIDR 방법은 **'IP 주소/서브넷 마스크상의 1의 개수'** 형식으로 표기하는 방법이다. 가장 간단하고 직관적이기 때문에 주로 사용되는 방법이다.\n\n![255.255.255.0 -> 11111111.11111111.11111111.00000000(1의 개수 24개)](IP_7.png)\n\n## 공인 IP 주소와 사설 IP 주소\nIP 주소가 MAC 주소와 같이 고유한 특성이 있다고 생각할 수 있는데, 이는 반만 맞는 말이다. 공인 IP의 경우 전 계에서 고유한 IP이지만, 사설 IP는 중복될 수 있는 IP이다.\n\n### 공인 IP 주소\n공인 IP 주소는 전 세계에서 고유한 IP 주소이다. 네트워크 간의 통신, 혹은 인터넷을 사용할 때 사용하는 주소가 공인 IP 주소이다. 공인 IP 주소는 ISP나 공인 IP 주소 할당 기관을 통해 할당 받을 수 있다.\n\n### 사설 IP 주소와 NAT\n사설 IP 주소란 사설 네트워크에서 사용하기 위한 IP 주소이다. 사설 네트워크란 인터넷, 외부 네트워크에 공개되지 않는 네트워크를 의미한다. LAN의 많은 호스트들이 이 사설 IP 주소를 사용한다.\n\n사설 IP 주소는 특별히 예약된 IP 주소 공간이 있다. 다음 IP 주소 범위의 IP들은 사설 IP 주소로 간주하기로 약속되어 있다.\n- `10.0.0.0/8` (10.0.0.0 ~ 10.255.255.255)\n- `172.16.0.0/12` (172.16.0.0 ~ 172.31.255.255)\n- `192.168.0.0/16` (192.168.0.0 ~ 192.168.255.255)\n\n사설 IP 주소는 주로 **라우터**에서 할당하며 사설 IP 주소는 해당 호스트가 속한 네트워크 상에서만 유효함으로 얼마든지 다른 네트워크상의 사설 IP와 중복될 수 있다. \n\n하지만 사설 IP 만으로는 다른 네트워크와의 통신이 어렵기 때문에 호스트가 외부의 네트워크와 통신하기 위해서는 **NAT(Network Address Translation)** 이라는 IP주소 변환 기술을 사용해야 한다. NAT은 주로 사설 IP 주소를 공인 IP 주소로 변환하는데 사용하며 NAT을 통해 사설 IP 주소를 사용하는 여러 호스트는 적은 수의 공인 IP 주소를 공유할 수 있다.\n\n대부분의 라우터와 가정용 공유기는 NAT기능을 내장하고 송수신시 아래와 같은 작업을 진행해준다.\n\n**송신시** - 사설 IP 주소로 통신시에 공유기를 거쳐 공인 IP 주소로 변환되고, 외부 네트워크로 전송된다.\n\n**수신시** - 외부 네트워크로부터 받은 패킷 속 공인 IP 주소는 공유기를 거쳐 사설 IP 주소로 변경되어 사설 네트워크 속 호스트에 도달한다.\n![NAT은 사설 IP를 공인 IP로, 공인 IP를 사설 IP로 변환해준다](IP_8.png)\n\n## 정적 IP 주소와 동적 IP 주소\n호스트에 IP 주소를 할당하는 방법은 정적으로 할당하는 방법과 동적으로 할당하는 방법이 있다. \n### 정적 할당 \n정적 할당은 호스트에 직접 수작업으로 IP를 부여하는 방식이다. 정적 할당으로 할당된 IP 주소를 **정적 IP 주소**라고 부른다. \n\n각 OS마다 설정 방법은 조금씩 다를 수 있으나, 네트워크 설정에서 부여하고자 하는 IP 주소, 서브넷 마스크, 게이트웨이(라우터) 주소, DNS 주소를 입력하면 고정된 정적 IP 주소를 할당할 수 있다.\n![윈도우, MAC OS의 설정 화면](IP_9.png)\n\n### 동적 할당과 DHCP\n만약 수천가지의 호스트를 정적 할당으로 IP를 할당한다면, 중복되는 IP가 생기는 등의 문제가 발생할 것이다. 이런 문제를 해결하기 위해 호스트의 IP가 자동으로 할당되는 **동적 할당**이 있다. 동적 할당으로 할당된 IP는 **동적 IP 주소**라고 부르며 지금의 호스트 IP 할당은 대부분 동적 할당으로 진행한다.\n\n#### DHCP\nIP를 동적으로 할당하기 위한 대표적인 프로토콜이 **DHCP(Dynamic Host Configuration Protocol)** 이다. DHCP를 통한 IP 주소 할당은 할당 받고자 하는 호스트와 해당 호스트에게 IP 주소를 제공하는 **DHCP서버** 간에 메시지를 주고 받음으로써 이루어 진다. DHCP 서버의 역할은 일반적으로 라우터(공유기)가 수행하지만, 특정 호스트에 DHCP 서버 기능을 추가할 수도 있다.\n\nDHCP로 할당 받은 IP 주소는 **사용할 기간(임대 기간)이 정해져 있어** 임대 기간이 끝난 IP 주소는 일반적으로 DHCP 서버에 IP 주소가 반납된다. 그래서 DHCP를 통해 IP 주소를 할당받는 것을 **\"IP 주소를 임대한다\"** 라고 표현하기도 한다.\n\nIP 주소를 할당받는 과정에서 클라이언트와 DHCP서버 간에 주고받는 메시지의 종류는 아래와 같다.\n1. DHCP Discover\n2. DHCP Offer\n3. DHCP Request\n4. DHCP ACK(Acknowledgment)\n\n![1 ~ 4 순서대로 통신을 진행한다](IP_10.png)\n\n##### 1. DHCP Discover(클라이언트 -> DHCP 서버)\n클라이언트가 DHCP 서버를 찾기위해 전송하는 메시지 이다. 프로트캐스트로 DHCP Discover 메시지를 전송하며 전송 시점에서 클라이언트는 아직 IP 주소를 할당받지 못했으므로 송신지 IP 주소는 0.0.0.0으로 설정된다.\n\n##### 2. DHCP Offer(DHCP 서버 -> 클라이언트)\nDHCP 서버가 DHCP Discover 메시지를 받은 뒤 클라이언트에게 DHCP Offer 메시지를 보낸다. DHCP Offer 메시지는 클라이언트에게 할당해 줄 IP 주소를 제안하는 메시지 이다. 클라이언트에게 제안할 IP 주소 뿐만 아니라 서브넷 마스크, 임대 기간등의 정보도 포함되어 있다.\n\n##### 3. DHCP Request(클라이언트 -> DHCP 서버)\nDHCP Request는 DHCP Offer에 대한 응답이다. 이 메시지 또한 브로드캐스트로 전송된다. DHCP Offer 메시지를 잘 전송 받고, 이 IP 주소를 사용해도 되는지 묻는 것과 같다.\n\n##### 4. DHCP ACK(DHCP 서버 -> 클라이언트)\n마지막으로 DHCP 서버는 클라이언트에게 DHCP ACK 메시지를 보낸다. 이 메시지는 최종 승인과도 같은 메시지이다. DHCP ACK 메시지까지 받은 클라이언트는 이제 할당받은 IP 주소를 자신의 IP 주소로 설정한 뒤 임대 기간동안 IP 주소를 사용한다.\n\n##### DHCP의 임대 갱신\nIP 주소의 사용 기간이 모두 끝난경우 DHCP 서버에 반납되며 원칙적으로는 할당 과정을 다시 거쳐야 한다. 하지만 IP 주소 임대 기간이 끝나기 전에 임대 기간을 연장할 수 도 있다. 이를 **임대 갱신**이라고 한다. 임대 갱신은 IP 주소의 임대 기간이 끝나기 전에 기본적으로 **두 차례 자동으로 수행**하며 임대 갱신 시도가 **두 차례 모두 실패하면 그때 IP 주소는 DHCP 서버로 반납**된다."},{"excerpt":"데이터 링크 계층의 한계 물리 계층과 데이터 링크 계층 만으로는 LAN을 넘어선 통신을 하기에 어려움이 있다.  1. 물리 계층과 데이터 링크 계층 만으로는 다른 네트워크까지의 도달 경로를 파악하기 어렵다. 호스트가 패킷을 송신할 때, LAN에 속한 호스트에게만 송신하지 않기 때문에 패킷은 서로에게 도달하기 위해서 수많은 네트워크 장비들을 거치고 다양한 …","fields":{"slug":"/NetworkLayer/"},"frontmatter":{"date":"April 30, 2025","title":"LAN을 넘어서는 네트워크 계층","tags":["Network","네트워크-계층"]},"rawMarkdownBody":"## 데이터 링크 계층의 한계\n물리 계층과 데이터 링크 계층 만으로는 LAN을 넘어선 통신을 하기에 어려움이 있다. \n#### 1. 물리 계층과 데이터 링크 계층 만으로는 다른 네트워크까지의 도달 경로를 파악하기 어렵다.\n호스트가 패킷을 송신할 때, LAN에 속한 호스트에게만 송신하지 않기 때문에 패킷은 서로에게 도달하기 위해서 수많은 네트워크 장비들을 거치고 다양한 경로를 통해 이동한다. 이때, 통신을 빠르게 주고 받기 위해 패킷이 이동할 최적의 경로를 결정하는 것을 **라우팅**이라고 한다. \n\n물리 계층과 데이터링크 계층의 장비로는 라우팅을 수행할 수 없지만, 네트워크 계층의 **라우터**를 사용하면 라우팅을 수행할 수 있다.\n\n#### 2. MAC 주소만으로는 모든 네트워크에 속한 호스트의 위치를 특정하기 어렵다.\n현실 적으로 모든 호스트가 모든 네트워크에 속한 모든 호스트의 MAC 주소를 서로 알고 있기란 불가능에 가깝다. 그래서 특정 NIC의 MAC 주소 이외에 수신지를 알 수 있는 어떠한 주소가 필요하다. 이 수신지 역할을 하는것이 바로 **IP 주소**이다.\n\n네트워크에서는 MAC 주소와 IP 주소를 함께 사용하고, 기본적으로 IP 주소를 우선으로 활용한다.\n![IP 주소는 수신지, MAC 주소는 수신인 역할을 한다](NL_1.png)\n\nMAC 주소를 물리 주소라 부르는 것처럼 IP 주소는 **논리 주소**라고도 불린다. 또, MAC 주소는 일반적으로 NIC 마다 할당되는 고정된 주소이지만, IP 주소는 호스트에 직접 할당이 가능하다. **DHCP(Dynamic Host Configuration Protocol)** 라는 특정 프로토콜을 동해 자동 할당도 가능하며 직접 할당하거나 한 호스트가 복수의 IP 주소를 가질 수도 있다.\n\n## 인터넷 프로토콜 (IP)\n네트워크 계층의 핵심적인 프로토콜은 **인터넷 프로토콜(Internet Protocol, IP)** 이다. IP는 IPv4와 IPv6의 2가지 버전이 있다.\n### IP주소의 형태 (IPv4)\n4바이트(32 비트)로 주소를 표현할 수 있고, 숫자당 8비트로 표현되기에 0~225 범위 안에있는 네개의 10진수로 표기된다. 각 10진수는 점으로 구분되며, 점으로 구분된 8비트를 **옥텟**이라고 한다. \n![192, 168, 1, 1 각각은 8비트로 표현된 옥텟이다](NL_2.png)\n\n### IP의 기능\nIP는 크게 2가지의 기능이 있다. **IP주소 지정**과 **IP 단편화 기능**이다.\n\n#### IP 주소 지정\nIP 주소를 바탕으로 송수신 대상을 지정하는 것을 의미한다. \n\n#### IP 단편화\n전송하고자 하는 패킷의 크기가 MTU라는 최대 전송 단위보다 클 경우, 이를 MTU 크기 이하의 복수의 패킷으로 나누는 것을 의미한다. \n\n여기서 **MTU**란 한번에 전송 가능한 IP 패킷의 최대 크기를 의미한다. 일반적인 MTU의 크기는 1500바이트이며, MTU 크기 이하로 나누어진 패킷은 수신지에 도착하면 다시 재조합된다.\n![MTU 크기 이하만큼 패킷이 나누어져 전송된다](NL_3.png)\n> IP 패킷의 헤더도 MTU 크기에 포함된다는 점을 유의해야 한다.\n\n### IPv4\nIPv4 패킷은 프레임의 페이로드로 데이터 필드에 명시된다.\n![프레임의 데이터 필드에는 상위 계층에서 전달받거나 상위 계층으로 전달애햐 할 내용이 들어간다](NL_4.png)\n\nIPv4는 아래 그림과 같은 형태를 띄고 있다. 그중에서도 가장 핵심이 되는 필드만 하나씩 살펴보겠다.\n![](NL_5.png)\n\n#### 식별자\n패킷에 할당된 번호이다. 만일 메시지 전송 과정에서 IPv4 패킷이 여러 조각으로 쪼개져서 전송되었다면, 수신지에서는 이들을 재조합하여야 한다. 이때 수신지에서 쪼개진 패킷들이 **어떤 메시지에서부터 쪼개졌는지를 인식**하기 위해 식별자를 사용한다.\n\n#### 플래그\n플래그는 총 세 개의 비트로 구성된 필드이다. 이중 첫번째 비트는 항상 0으로 예약된 비트로 사용되지 않는다.\n사용되는 나머지 두 개의 비트중에서 하나는 **DF(Don't Fragment)**, 나머지 하나는 **MF(More Fragment)** 라는 비트이다.\n\nDF는 IP 단펴화를 수행하지 말라는 표시로, 이 비트가 1로 설정되어 있다면 단편화를 수행하지 않고, 0이라면 IP 단편화가 가능하다.\n\nMF는 단편화된 패킷이 더 있는지를 나타낸다. 0이라면 이 패킷이 마지막 패킷임을 의미하고, 1이라면 쪼개진 패킷이 아직 더 있다는 것을 의미한다.\n\n![플래그 필드의 모습](NL_6.png)\n\n#### 단편화 오프셋\n단편화 오프셋은 패킷이 **단편화되기 전에 패킷의 초기 데이터에서 몇 번째로 떨어진 패킷**인지를 나타낸다. 단편화된 패킷들이 순서대로 도착하기 않기 때문에 패킷을 재조합 할때 각 패킷이 몇 번째 데이터 인지 판단할 때 사용한다.\n![단편화 오프셋이 0이라면 첫 번째 패킷이라는 것을 알 수 있다](NL_7.png)\n\n#### TTL\nTime To Live의 약어로 패킷의 수명을 의미한다. TTL은 패킷이 하나의 라우터를 거칠 때마다 1씩 감소하며, 0으로 떨어진 패킷은 폐기된다. \n\n패킷이 호스트 또는 라우터에 한번 전달되는 것을 **홉(hop)** 이라고 한다. 무의미한 패킷이 네트워크 상에 지속적으로 남아있는 것을 방지하기 위해 사용한다.\n![](NL_8.png)\n\n#### 프로토콜\nIP 패킷의 프로토콜 필드는 **상위 계층의 프로토콜이 무엇인**지 나타낸다. 예를 들어 전송 계층의 대표적인 프로토콜인 TCP는 6번 UDP는 17번 이다.\n\n#### 송신지 IP 주소와 수신지 IP 주소\n이름 그대로 송수신지의 IPv4 주소를 알 수 있다.\n\n### IPv6\nIPv6는 IPv4 주소의 고갈 문제를 해결하기 위한 주소입니다. 16바이트(128비트)로 주소를 표현할 수 있고, 콜론으로 구분된 8개 그룹의 16진수로 표기된다. 이론상 2^128 개로 사실상 무한에 가까운 수를 할당할 수 있다.\n![](NL_9.png)\n\nIPv6의 구성은 아래와 같이 생겼다.\n![](NL_10.png)\n\n#### 다음 헤더\n다음 헤더 필드는 상위 계층의 프로토콜을 가리키거나 **확장 헤더**를 가리킨다. 확정 헤더는 IPv6에 추가적인 헤더 정보가 필요할 경우 **기본 헤더와 더불어 추가되는 헤더**이다. 확장 헤더는 기본 헤더와 페이로드 데이터 사이에 위치하며 상황에 맞는 다양한 정보를 운반할 수 있다.\n![](NL_11.png)\n![](NL_12.png)\n> #### IPv6에서의 단편화\n> IPv6에서는 IPv4에서 보이는 단편화를 위한 필드가 없어 **단편화 확장 헤더**를 통해 단편화가 이루어 진다.\n> ![](NL_13.png)\n> 단편화 확장 헤더에도 다음 헤더 필드가 존재하며, 예약됨과 예약 필드는 0으로 설정되어 사용되지 않는다.\n\n#### 홉 제한\nIPv4의 TTL 필드와 비슷하게 패킷의 수명을 나타내는 필드이다.\n\n#### 송신지 IP 주소와 수신지 IP 주소\n송신지 수조와 수신지 주소를 통해 IPv6 주소 지정이 가능하다.\n\n## ARP\n네트워크 통신 과정에서 **\"상대 호스트의 IP 주소는 알지만, MAC 주소는 알지 못하는 상황\"** 에서 사용하는 프로토콜이다.\n\nIP 주소를 통해 MAC 주소를 알아내는 프로토콜로 동일 네트워크 내에 있는 송수신 대상의 IP 주소를 통해 MAC 주소를 알아낼 수 있다.\n\nARP의 동작 과정은 다음과 같다.\n1. ARP 요청\n2. ARP 응답\n3. ARP 테이블 갱신\n\n> [스위치](https://bjcho0501.github.io/blog/NetworkSwitch/) 글에서의 MAC 주소 학습과 유사한 느낌이 있는데, **MAC 주소 학습의 주체는 스위치**이라는 점이 중요하다. 스위치가 MAC 주소를 학습했다고 해서 호스트들끼리 서로의 MAC 주소를 학습하는 것은 아니다.\n\n### ARP 요청\nA호스트가 B호스트에게 패킷을 보내고 싶어 하는 상황에서, A호스트는 B호스트의 IP 주소는 알지만 MAC 주소를 모르기 때문에 A호스트는 네트워크 내의 모든 호스트에게 브로드캐스트 메시지를 보낸다. 이 요청은 **ARP 요청** 이라는 ARP 패킷이다.\n![A가 ARP 요청을 진행한다](NL_14.png)\n\n### ARP 응답\n네트워크 내의 모든 호스트가 ARP 요청 메시지를 수신하지만, B를 제외한 나머지 호스트는 자신의 IP 주소가 아니므로 이를 무시한다.\n\nB는 자신의 MAC 주소를 담은 메시지를 A에게 유니캐스트로 전달한다. 이 메시지가 **ARP 응답** 이라는 ARP 패킷이다. 이 과정을 통해 A호스트는 B의 MAC 주소를 알게된다.\n![B는 A에게 MAC 주소가 담긴 ARP 응답을 한다](NL_15.png)\n\n### ARP 테이블 갱신\nARP를 활용할 수 있는 모든 호스트는 **ARP 테이블** 이라는 정보를 유지한다. ARP 테이블은 IP 주소와 그에 맞는 MAC 주소를 테이블 형태로 대응해둔 표이다. \n\nARP 요청과 ARP 응답으로 ARP 테이블에 IP 주소와 MAC 주소의 관계 정보를 저장하게 되고, 이후에 MAC 주소를 아는 호스트에게는 통신 시에 브로드캐스트로 ARP 요청을 보낼 필요가 없게 된다. \n\nARP 테이블은 일정 시간이 지나면 삭제되고, 임의로 삭제할 수도 있다.\n\n![A호스트의 ARP 테이블에 B호스트의 MAC 주소가 저장된 모습](NL_16.png)\n\n> ARP 테이블은 ARP 캐시, APR 캐시 테이블 이라고도 부른다.\n\n### 다른 네트워크에서의 ARP\nARP는 \"동일 네트워크\" 내에 있는 호스트의 IP 주소를 통해 MAC 주소를 알아내는 프로토콜이라고 하였다. 하지만 만일 동일한 네트워크에 있는 호스트가 아니라면, 어떤식으로 동작할까?\n\n> 그림의 동그라미 범위는 각각 서로 다른 네트워크 범위를 의미한다.\n\n먼저 다른 네트워크로 통하는 라우터(아래 사진에서는 라우터 A)의 MAC 주소를 알아내기 위해 ARP를 실행한다.\n\n![호스트 A -> 라우터 A](NL_17.png)\n이후에 `라우터 A`는 `라우터 B`의 MAC 주소를 알아내기 위해 ARP를 실행한다.\n![라우터 A -> 라우터 B](NL_18.png)\n마지막으로 `라우터 B`는 `호스트 B`의 MAC 주소를 알아내기 위해 ARP를 실행한다.\n![라우터 B -> 호스트 B](NL_19.png)\n결론적으로 다른 네트워크에 속해있는 호스트와 통신할때는 **네트워크 별로 ARP가 수행**된다는 것을 알 수 있다."},{"excerpt":"스위치 스위치는 데이터 링크 계층의 네트워크 장비이다. 2계층에서 사용한다 하여 L2 스위치 라고도 부른다. 스위치는 여러 포트에 여러 호스트를 연결할 수 있다는 점에서 허브와 유사한 점이 있지만, 허브와 달리 MAC 주소를 학습해 특정 MAC 주소를 가진 호스트에만 프레임을 전달할 수 있고 전이중 모드의 통신을 지원한다. 이로 인해 허브보다 성능에 이점…","fields":{"slug":"/NetworkSwitch/"},"frontmatter":{"date":"April 28, 2025","title":"스위치 (딸깍)","tags":["Network","스위치"]},"rawMarkdownBody":"## 스위치\n스위치는 데이터 링크 계층의 네트워크 장비이다. 2계층에서 사용한다 하여 **L2 스위치** 라고도 부른다.\n\n스위치는 여러 포트에 여러 호스트를 연결할 수 있다는 점에서 허브와 유사한 점이 있지만, 허브와 달리 MAC 주소를 학습해 **특정 MAC 주소를 가진 호스트에만 프레임을 전달**할 수 있고 **전이중 모드의 통신을 지원**한다. 이로 인해 허브보다 성능에 이점이 있다.\n\n### 스위치의 특징\n#### 1. MAC 주소 학습\n스위치의 가장 중요한 특징중 하나로 포트와 해당 포트에 연결되어 있는 호스트의 MAC 주소와의 관계를 기억한다는 특징이다. 이를 통해 원하는 호스트에만 프레임을 전달할 수 있다.\n\n#### 2. MAC 주소 테이블\nMAC 주소 학습을 위해 포트와 포트에 연결된 호스트의 MAC 주소 간의 관계를 메모리에 표 형태로 기억하는 특징이 있다. 이러한 테이블을 **MAC 주소 테이블**이라고 한다.\n\n## 스위치가 MAC 주소를 학습하는 방법\n스위티가 MAC 주소를 학습하기 위해 세 가지 기능을 가지고 있다.\n1. 플러딩\n2. 포워딩과 필터링\n3. 에이징\n\n#### 스위치의 MAC 주소 학습 순서\n스위치의 MAC 주소 학습은 프레임 내 **\"송신지 MAC 주소\"** 를 통해 이루어 진다. 만일 스위치가 호스트 A의 프레임을 수신하면, 해당 프레임의 송신지 MAC 주소를 확인한 후 MAC 테이블에 기록한다. \n\n즉 호스트가 한번은 스위치를 거쳐서 프레임을 송신해야 MAC 주소 테이블에 정보가 기록되는 것이다.\n![호스트 A가 프레임을 송신하여 MAC 주소 테이블에 정보가 기록된 모습](Switch_mac_1.png)\n\n\n#### 플러딩\n아래 그림에서 호스트 A가 호스트 C에게 프레임을 전송한다 가정 하였을 때, 스위치의 MAC 주소 테이블에는 아무 MAC 주소도 없기 때문에 특정 포트에만 프레임을 전송하는 것이 불가능하다.\n\n이런 상황에서 스위치가 마치 허브처럼 송신지 포트를 제외한 모든 포트로 프레임을 전송하는 동작을 **플러팅**이라고 한다.\n![호스트 A의 1번 포트를 제외한 모든 포트에 프레임을 전송하는 모습](Switch_mac_2.png)\n\n플러딩을 진행하면 호스트 B와 D는 프레임을 폐기하게 되고, 호스트 C는 프레임을 송신받게 된다. 이후 호스트 C는 스위치로 응답 프레임을 전송하여 호스트 C의 MAC주소와 호스트 C에 연결되어 있는 포트와의 관계가 MAC 주소 테이블에 저장되게 된다.\n![호스트 C와 포트 3번의 관계가 MAC 주소 테이블에 저장된 모습](Switch_mac_3.png)\n\n#### 포워딩과 필터링\n포워딩과 필터링이란 MAC 주소 테이블에 기록된 정보를 바탕으로 호스트에게 전달받은 프레임을 특정 포트에 보내도록 하는 동작이다.\n\n전달받은 프레임을 어디로 내보내고 어디로 내보내지 않을지 결정하는 기능이 **필터링**,<br/>\n그리고 프레임이 전송될 포트에 실제로 프레임을 내보내는 것이 **포워딩**이다.\n![호스트 A가 보낸 프레임을 호스트 C에게 보내기 위해 필터링 후 포워딩 하는 모습](Switch_mac_4.png)\n\n#### 에이징\n에이징은 만약 MAC주소 테이블에 등록된 특정 포트에서 **일정 시간동안 프레임을 전송받지 못했다면 해당 항목을 삭제**하는 동작이다.\n\n## VLAN\n스위치의 또 다른 기능으로는 가상의 LAN 환경을 구축하는 **VLAN(Virtual LAN)** 기능이 있다. VLAN은 한 대의 스위치로 가상의 LAN을 만드는 방법이다. \n\nVLAN을 사용하는 이유는 스위치에 연결되어 있는 호스트 중에서도 서로 관계가 없어 메시지를 주고 받지 않아도 되는 상황(브로트캐스트 메시지 등)에서 매번 새로운 스위치 장비를 구비하지 않고 서로를 분리하여 **성능 저하를 방지**하기 위함이다.\n![같은 스위치에서 마치 여러 대의 스위치가 있는 듯이 LAN을 분리한 모습](Switch_mac_5.png)\n\n### 포트 기반 VLAN\nVLAN을 구성하는 방법중 하나로 가장 단순하지만 대중적으로 사용하는 방식이다. 이름 그대로 **\"스위치의 포트가 VLAN을 결정하는 방식\"** 이다. \n\n아래 그림처럼 사전에 특정 포트에 VLAN을 할당하고, 해당 포트에 호스트를 연결함으로써 VLAN에 포함시키는 것이다.\n![포트 기반 VLAN](Switch_mac_6.png)\n\n하지만 한 대의 스위치 만으로 포트 기반 VLAN을 사용하면, 포트 수가 부족해 질 수 있다는 문제가 있다. 이럴 때 사용하는 방법이 **VLAN 트렁킹** 이다.\n\n#### VLAN 트렁킹\n**VLAN 트렁킹**은 스위치 간의 통신을 위한 특별한 포트인 **트렁크 포트**를 사용하여 VLAN 스위치를 서로 연결하는 방식이다. \n> 트렁크 포트는 **태그 포트**라고도 부르며, 태그 포트 이외의 VLAN에 할당된 일반적인 포트는 **액세스 포트**라고 한다.\n\n![트렁킹 포트를 사용해 스위치끼리의 VLAN을 확장할 수 있다](Switch_mac_7.png)\n\n> #### 트렁크 포트로 전달받은 프레임이 어떤 VLAN에 속하는지 파악하는 방법\n> 트렁크 포트로 연결되어 있는 스위치끼리 전달 받는 프레임이 어떤 VLAN에 속하는지 확인하는 방법은 확장된 이더넷 프레임을 사용하는 것이다.\n> \n> 확장 이더넷 프레임인 **802.1Q 프레임**을 사용하면 VLAN의 식별 정보를 담은 **VLAN 태그**를 통해 해당 프레임이 어떤 VLAN에 대한 프레임인지 식별할 수 있다.\n> ![802.1Q 프레임](Switch_mac_8.png)\n\n\n### MAC 기반 VLAN\nMAC 기반 LAN은 사전에 설정된 MAC 주소에 따라 VLAN이 결정되는 방식이다. 포트 기반 VLAN과 달리 송수신하는 프레임 속 MAC 주소가 호스트가 속할 VLAN을 결정하는 방식 인것이다.\n![MAC 기반 VLAN](Switch_mac_9.png)"},{"excerpt":"네트워크 장비 네트워크 장비에는 허브와 스위치 등이 있다. 허브는 물리 계층을 대표하는 장비이고, 스위치는 데이터 링크 계층을 대표하는 장비이다.  주소 개념이 없는 물리 계층 물리 계층과 데이터 링크 계층의 차이점중 하나는 물리 계층에는 주소 개념이 없고, 데이터 링크 계층에는 있다는 것이다. 물리 계층에서는 단지 호스트와 통신 매체 간의 연결과 통신 …","fields":{"slug":"/NetworkHub/"},"frontmatter":{"date":"April 25, 2025","title":"허브","tags":["Network","허브"]},"rawMarkdownBody":"## 네트워크 장비\n네트워크 장비에는 허브와 스위치 등이 있다. 허브는 물리 계층을 대표하는 장비이고, 스위치는 데이터 링크 계층을 대표하는 장비이다.\n\n![](Hub_ex_1.png)\n\n## 주소 개념이 없는 물리 계층\n물리 계층과 데이터 링크 계층의 차이점중 하나는 물리 계층에는 주소 개념이 없고, 데이터 링크 계층에는 있다는 것이다. 물리 계층에서는 단지 호스트와 통신 매체 간의 연결과 통신 매체상의 송수신이 이루어 질 뿐, 송수신 되는 정보의 어떠한 조작이나 판단을 하지 않는다.\n\n반면, 데이터 링크 계층의 경우 MAC주소라는 주소 개념이 존재한다. 따라서 데이터 링크 계층의 장비나 그 이상의 계층 장비들은 송수신지를 특정할 수 있고, 주소를 바탕으로 송수신 되는 정보에 대한 조작과 판단이 가능하다.\n![물리 계층에는 주소 개념이 없고, 데이터 링크 계층 이상부터 주소 개념이 있다](Hub_level_add_1.png)\n\n## 허브\n물리 계층의 허브는 **여러 대의 호스트를 연결**하는 장치이다. 리피터 허브라고 부르기도 하며, 이더넷 네트워크의 허브는 이더넷 허브라고 부른다.\n\n허브는 커넥터를 연결할 수 있는 포트라는 지점이 있으며, 포트에 호스트의 연결 매체를 연결할 수 있다.\n![허브의 모습](Hub_ex_2.png)\n\n### 허브의 특징\n#### 1. 전달 받은 신호를 다른 모든 포트로 그대로 다시 내보낸다.\n허브는 물리 계층에 속하여 주소 개념이 없기 때문에 수신지를 특정할 수 없다. 그래서 허브는 신호를 전달 받으면 어떠한 조작이나 판단을 하지 않고 송신지를 제외한 모든 포트에 신호를 내보내기만 한다. 이러한 신호는 데이터 링크 계층에서 패킷의 MAC 주소를 확인하고 자신과 관련 없는 주소는 폐기한다.\n![수신 받은 신호를 다른 모든 포트로 내보낸다](Hub_option_1.png)\n\n#### 2. 반이중 모드로 통신한다.\n반이중 모드란, 마치 1차선 도로처럼 송수신을 번갈아 가면서 하는 방식이다. 동시에 송수신이 불가능 하며 다른 쪽의 송신이 끝나야 자신의 송신이 가능한 것이다.\n![무전기와 같이 한방향으로만 송수신이 가능하다](Hub_half_mode.png)\n\n> #### 반이중 모드의 반대, 전이중 모드\n> 반이중 모드의 반대로 전이중 모드가 있다. 전이중 모드는 송수신을 동시에 양방향으로 할 수 있는 모드이다.\n> ![양방향으로 동시에 송수신이 가능하다](Hub_full_mode.png)\n\n### 콜리전 도메인\n허브는 반이중 모드로 통신하기 때문에 동시에 송수신이 불가능 하다고 하였다. 하지만 만일 동시에 허브에 신호를 송신하면 **충돌(Collision, 콜리전)**이 발생한다.\n\n허브에 호스트가 많이 연결되어 있을수록 충돌 발생 가능성이 높아진다. 그리고 이렇게 충돌이 발생할 수 있는 영역을 **콜리전 도메인(Collision Domain)** 이라고 한다.\n![허브에 연결되어 있는 모든 호스트는 같은 콜리전 도메인에 속한다](Hub_collision_domain.png)\n\n허브의 넓은 콜리전 도메인으로 인한 충돌 문제를 해결하려면 **CSMA/CD 프로토콜**을 사용하거나 스위치 장비를 사용해야 한다.\n\n## CSMA/CD\nCSMA/CD는 허브와 같이 반이중 모드에서의 동시 신호 송신으로 인한 충돌을 해결하기 위한 대표적인 프로토콜이다. \n\n**CSMA/CD**는 **Carrier Sense Multiple Access with Collision Detection**의 약자이다. 단어 하나하나를 살펴보며 **CSMA/CD**에 대해 이해해보자.\n\n### 1. CS는 Carrier, 캐리어 감지를 의미한다.\nCSMA/CD프로토콜을 사용중인 반이중 이더넷 네트워크에서는 메시지를 보내기 전에 현재 네트워크상에서 전송 중인 것이 있는지 먼저 확인한다. 이러한 확인 화정을 **캐리어 감지(Carrier Sense)**라고 한다.\n\n> 엄밀히 말하면 반송파 감지를 의미한다고 한다.\n\n### 2. MA는 Multiple Access, 다중 접근을 의미한다.\n위의 캐리어 감지를 진행 하여도, 부득이 하게 동시에 네트워크를 사용하려 할 때가 있다. 복수의 호스트가 네트워크에 접근하려는 상황을 **다중 접근(Multiple Access)**라고 한다.\n\n### 3. CD는 Collision Detection, 충돌 검출을 의미한다.\n충돌이 발생하면 이를 검출 하는것을 **충돌 검출(Collision Detection)** 이라고 한다. 충돌을 감지하면 전송이 중단되고, 충돌을 검출한 호스트는 다른 호스트에게 충돌이 발생했음을 알리는 **잼 신호(jam signal)** 라는 특별한 신호를 보낸다. 그리고 임의의 시간 동안 기다린 뒤 다시 전송한다.\n![Collision Detection](Hub_CD.png)\n\n정리하면, 반이중 이더넷 네트워크에서 CSMA/CD 프로토콜을 사용하면 다음과 같은 순서의 작업을 진행한다.\n\n**호스트들은 메시지를 전송하기 전..**\n1. 먼저 현재 전송이 가능한 상태인지 확인하고,\n2. 다른 호스트가 전송 중이지 않을 때 메시지를 전송한다.\n3. 만일 부득이하게 다수의 호스트가 접근하여 충돌이 발생하면 임의의 시간만큼 대기한 후에 다시 전송한다."},{"excerpt":"NIC란? NIC(Network Interface Controller)는 호스트와 통신 메체를 연결하고, MAC 주소가 부여되는 네트워크 장비이다.  통신 매체에는 다양한 신호(전기, 빛)가 흐를 수 있어 해당 신호를 호스트가 이해할 수 있도록 변환하는 과정이 필요하다. 이때, 호스트와 유무선 통신 매체를 연결하고 이러한 변환을 담당하는 네트워크 장비가 …","fields":{"slug":"/NICAndCable/"},"frontmatter":{"date":"April 24, 2025","title":"NIC와 케이블","tags":["NIC","Network"]},"rawMarkdownBody":"## NIC란?\n**NIC(Network Interface Controller)**는 호스트와 통신 메체를 연결하고, MAC 주소가 부여되는 네트워크 장비이다. \n\n통신 매체에는 다양한 신호(전기, 빛)가 흐를 수 있어 해당 신호를 호스트가 이해할 수 있도록 **변환하는 과정이 필요**하다. 이때, 호스트와 유무선 통신 매체를 연결하고 이러한 변환을 담당하는 네트워크 장비가 NIC이다.\nNIC가 있어야 네트워크 신호를 받을 수 있고, 네트워크에 참여하여 다른 호스트에게 신호를 줄 수 있다.\n\n### NIC의 생김새\nNIC는 네트워크 인터페이스 카드, 네트워크 어댑터, LAN 카드, 네트워크 카드, 이더넷 카드 등 다양한 명칭으로 불리고 있다. \n\n우리에게 익숙한 LAN 카드도 NIC에 속하는 것인데, 이 외에 USB로 연결하거나 메인보드에 내장되어 있는 NIC도 있다.\n![해당 사진 이외에 여러 NIC가 있다](NIC_ex_1.png)\n\n### NIC의 역할\nNIC는 통신 매체에 흐르는 신호를 호스트가 이해하는 프레임으로 변환하거나 반대로 호스트가 이해하는 프레임을 통신 매체에 흐르는 신호로 변환한다.\n\n**통신 매체 -> NIC -> 호스트**\n\n**통신 매체 <- NIC <- 호스트**\n\nNIC는 네트워크의 연결점을 담당한다는 점에서 **네트워크 인터페이스** 역할을 수행한다고도 한다.\n\nNIC에는 자신의 MAC 주소가 아닌 다른 주소의 프레임도 수신되는데, 만약 자신의 MAC주소의 프레임이 아닌 경우 해당 프레임을 폐기할 수 도 있고, FCS 필드를 토대로 오류를 검출해 잘못된 프레임을 폐기하기도 한다.\n\n## 케이블\n케이블은 NIC에 연결되는 물리 계층의 유선 통신 매체이다. 대표적인 종류로는 트위스티드 페어 케이블, 광섬유 케이블이 있다.\n\n### 트위스티드 페어 케이블\n구리 선으로 전기 신호를 주고받는 통신매체 이다. 우리가 흔히 말하는 LAN 케이블이라 했을때 떠오르는 가장 익숙한 케이블이다.\n\n트위스티드 페어 케이블은 케이블 본체와 케이블의 연결부인 커넥터로 이루어져 있다. \n커넥터의 경우 주로 **RJ-45**라는 명칭을 자주 사용하며, 케이블 본체에는 구리선이 두가닥씩 꼬아져 있는 모습이다.\n![RJ-45 커넥터](Cable_RJ-45.png)\n![2가닥씩 꼬어져 있는 케이블 본체](Cable_line.png)\n\n구리선이 꼬아져 있는 구조상 트위스티드 페어 케이블에는 노이즈가 발생할 수 있는데, 이를 막기 위해 그물 모양의 철사인 **브레이드 실드**와 **포일 실드**를 사용한다.\n![브레이드와 포일](Cable_shield.png)\n\n사용한 실드에 따라 정해진 명칭이 있는데,  `XX` / `Y`TP의 형대를 띈다.\n`X`와 `Y`에는 U, S, F의 문자가 들어간다.\n\n**U**: 아무것도 감싸지 않음<br/>\n**S**: 브레이드 실드로 감쌈<br/>\n**F**: 포일 실드로 감쌈\n\n앞의 `XX`의 경우 케이블 외부를 감싸는 실드 종류가 명시되며, 2개의 실드를 사용할 수 있어 X가 2개 있는 것이다. `Y`의 경우 꼬인 구리 선 쌍을 감싸는 실드의 종류가 명시된다.\n![S/FTP과 SF/FTP 케이블](Cable_ex_1.png)\n\n### 광섬유 케이블\n광섬유 케이블은 이름 그대로 **빛(광신호)**를 이용해 정보를 주고 받는 케이블이다. 빛을 이용하여 전송하기 때문에 전기 신호에 비해 속도가 빠르고, 먼 거리까지 전송이 가능하며, 노이즈로부터 간섭받는 영향도 적다. 이런 장점 덕분에 광섬유 케이블은 대륙간 네트워크 연결에도 사용된다.\n\n광섬유 케이블은 다양한 커넥터의 종류가 있으며, 케이블 본체 내부에는 머리카락과 같은 형태의 광섬유로 구성되어 있다.\n![광섬유 케이블 커넥터 종류들](Cable_light_type.png)\n\n광섬유 한가닥의 중심에는 실질적으로 빛이 흐르는 부분인 **코어**가 있으며, 코어의 주위에서 코어 안의 빛을 가두는 **클래딩**이 있다. 코어와 클래딩 간에 빛의 굴절률 차이를 만들어 빛을 코어 내부에 가두는 원리이다.\n![코어와 클래딩](Cable_light_detail.png)\n\n광섬유 케이블은 코어의 지름에 따라 **싱글 모드 광섬유 케이블**과 **멀티 모드 광섬유 케이블**로 나뉜다.\n### 싱글 모드 광섬유 케이블\n코어의 지름이 8~10µm 정도이다. 코어의 지름이 작기 때문에 빛이 이동할 수 있는 경로가 하나 이상을 갖기 어렵고, 이를 두고 **\"모드가 하나다\"** \b라고 표현한다.\n![싱글 모드 광섬유 케이블의 단면도 예시](Cable_single_mode.png)\n싱글 모드 케이블은 파장이 긴 장파장 빛을 사용하며, 신호 손실이 적기에 장거리 전송에 적합하다. 하지만 멀티 모드에 비해 일반적으로 비용이 높다는 단점도 있다.\n\n### 멀티 모드 광섬유 케이블\n코어의 지름이 50~62.5µm 정도이다. 코어의 지름이 싱글 모드에 비해 크기 때문에 빛이 여러 경로로 이동할 수 있다. 이를 두고 **\"모드가 여러 개\"** 라고 표현한다.\n![](Cable_multi_mode.png)\n멀티 모드는 싱글 모드보다 전송 시 신호 손실이 클 수 있기에 주로 근거리 연결에 사용한다. 또한 멀티 모드 케이블은 싱글 모드에 비해 단파장의 빛을 사용한다."},{"excerpt":"이더넷 알아보기 이더넷은 현대 유선 LAN 환경에서 대중적으로 사용되는 기술로, 다양한 통신 매체의 규격들과 송수신 되는 프레임의 형태, 프레임을 주고 받는 방법 등이 정의된 네트워크 기술이다. 이전 글의 내용 중 네트워크 참조 모델의 과 에 공통적으로 사용되는 기술이기도 하다. 이더넷 표준 앞선 내용과 같이 이더넷은 \"유선 LAN 환경에서 대중적으로 사…","fields":{"slug":"/Ethernet/"},"frontmatter":{"date":"April 21, 2025","title":"이더넷은 무엇인가","tags":["Network","이더넷"]},"rawMarkdownBody":"\n## 이더넷 알아보기\n이더넷은 현대 유선 LAN 환경에서 대중적으로 사용되는 기술로, 다양한 통신 매체의 규격들과 송수신 되는 프레임의 형태, 프레임을 주고 받는 방법 등이 정의된 네트워크 기술이다.\n\n[이전 글](https://bjcho0501.github.io/blog/StartNetwork/)의 내용 중 네트워크 참조 모델의 `물리 계층`과 `데이터링크 계층`에 공통적으로 사용되는 기술이기도 하다.\n\n## 이더넷 표준 \n앞선 내용과 같이 이더넷은 \"유선 LAN 환경에서 대중적으로 사용되는 기술\" 이기 때문에 국제적으로 표준화가 이루어져 있다. \n\n전기전자공학자협회(IEEE)라는 국제 조직이 처음 이더넷 관련 기술을 **IEEE 802.3** 이라 표준화 하였고, 이에 따라 각기 다른 제조사의 네트워크 장비를 사용하더라도 동일한 형식의 프레임을 주고 받고 통신할 수 있게 되었다.\n\n> IEEE는 지금까지도 [새로운 표준](https://www.ieee802.org/3)을 개발하고 있다.\n\n## 통신 매체 표기 형태\n이더넷 표준 규격에 따라 구현된 통신 매체들을 지칭할 때에는 아래과 같은 형식으로 한눈에 알아볼 수 있게 표현한다.\n![전송속도/BASE/추가 특성 형태를 하고있다.](Eth_unit_1.png)\n\n### 1. 전송 속도\n말 그대로 해당 통신 매체의 지원 속도를 표기하는 부분이다. \n\n숫자만 표기되어 있으면 Mbps 속도, 숫자 뒤에 G가 붙는 경우 Gbps 속도를 의미한다.\n\n| 전송 속도 표기 |        의미        |\n| :------: | :--------------: |\n|    10    |      10Mbps      |\n|   100    |     100Mbps      |\n|   1000   | 1000Mbps (1Gbps) |\n|   2.5G   |     2.5Gbps      |\n|    5G    |      5Gbps       |\n|   10G    |      10Gbps      |\n|   40G    |      40Gbps      |\n|   100G   |     100Gbps      |\n### 2. BASE\nBASE는 **베이스밴드**의 약자로 **변조 타입**을 의미한다. **변조 타입**이란 비트 신호로 변환된 데이터를 통신 메체로 전송하는 방법을 의미한다.\n\n특별한 경우가 아니라면 보통 **BASE**를 사용한다고 기억하는 것이 좋다.\n\n> BASE 외에 BROAD로 표기하는 브로드밴트, PASS로 표기하는 패스밴트도 있다.\n\n### 3. 추가 특성\n추가 특성은 통신 매체의 특성을 명시한다. 명시하는 특성은 아래와 같이 여러개가 있다.\n- 전송 가능한 최대 사거리 (10BASE-**2**, 10BASE-**5**)\n- 물리 계층 인코딩 방식 - 데이터가 비트 신호로 변환되는 방식\n- 레인 수 - 비트 신호를 옮길 수 있는 전송로 수\n\n![](Eth_additional_1.png)\n\n## 통신 매체 종류\n다음은 가장 대중적인 통신 매체의 종류 예시이다.\n\n| 추가 특성 표기(통신 매체의 종류) | 케이블 종류       |\n| ------------------- | ------------ |\n| C                   | 동축 케이블       |\n| T                   | 트위스티드 페어 케이블 |\n| S                   | 단파장 광섬유 케이블  |\n| L                   | 장파장 광섬유 케이블  |\n![트위스티드 페어 케이블은 우리가 자주 보는 그 LAN선이다](Eth_line_type.png)\n\n지금까지 배운 내용들을 사용하면 아래와 같은 표기 형식들을 보고 해석이 가능해 진다.\n- 10BASE-T 케이블: 10Mbps 속도를 지원하는 트위스티드 페어 케이블\n- 100BASE-SX 케이블: 100Mbps 속도를 지원하는 단파장 광섬유 케이블\n- 1000BASE-LX 케이블: 1000Mbps 속도를 지원하는 장파장 광섬유 케이블\n\n> ‼️ 이더넷 표준과 통신 매체의 표기가 항상 일대일로 대응되는 것이 아니라는 것을 유의하자.\n\n### 이더넷 프레임\n지금까지는 물리 계층과 관련된 내용 이라면, 이번 이터넷 프레임은 데이터링크 계층에 관련된 내용이다.\n\n현대의 유선 LAN 환경은 대부분 이더넷을 기반으로 구성되어 있기 때문에 호스트가 데이터 링크 계층에서 주고 받는 프레임 형식도 정해져 있다. 즉 이더넷 프레임이란, **호스트가 이더넷 네트워크에서 주고 받는 프레임**을 의미한다.\n\n이더넷 프레임은 헤더와 트레일러를 추가하는 **캡슐화** 과정을 통해 만들어 지고, 수신지 입장에서는 프레임의 헤더와 트레일러를 제거하는 **역갭슐화** 과정을 거친다.\n\n이더넷 프레임은 아래와 같은 구성으로 이루어져 있다.\n![](Eth_frame_1.png)\n**헤더**\n- 프리앰블\n- 수신지 MAC 주소\n- 송신지 MAC 주소\n- 타입/길이\n\n**페이로드**\n- 데이터\n\n**트레일러**\n- FCS\n\n### 프리앰블\n**프리앰블**은 이더넷 프레임의 시작을 알리며 송수신지 간의 동기화를 위해 사용되는 정보이다. \n\n8바이트(64비트) 크기를 가지고 있으며, 첫 7바이트는 `10101010`값을 마지막 바이트는 `10101011` 값을 가진다. \n\n### 수신지 MAC 주소와 송신지 MAC 주소\n\"물리적 주소\" 라고도 불리는 `MAC 주소`는 데이터 링크 계층의 핵심이다. \n\nMAC주소는 네트워크 인터페이스마다 부여되는 6바이트(48비트) 길이의 주소로, LAN 내의 수신자와 송신자를 특정할 수 있다. MAC 주소는 일반적으로 고유하고, 일반적으로 변경되지 않는 주소로써 네트워크 인터페이스마다 부여된다. 보동 **NIC(Network Interface Controller)** 라는 장치가 네트워크 인터페이스 역할을 담당하며, 한 컴퓨터의 NIC가 여러 개 있다면 MAC 주소도 여러개 있을 수 있다.\n\n> #### MAC 주소는 반드시 고유하지 않다!\n> 위 내용에서 \"일반적으로\" 고유하고 변경되지 않는다고 하였는데, 이는 MAC 주소도 고유하지 않거나 변경 가능할 수 있기 때문이다.\n> \n> MAC 주소가 우연히 같을 확률은 낮고, 의도적으로 같게 만드는 상황이 흔하지는 않기 때문에 **\"일반적으로 고유하고, 변경되지 않는 주소\"** 정도로 표현하는 것이다.\n\n### 타입/길이\n**타입/길이** 필드에는 **타입**이나 **길이**가 올 수 있다.\n\n만약 필드에 명시된 크기가 1500(16진수 05DC) 이하일 경우 길이를 나타내는 데 사용되고, 1536(16진수 0600) 이상일 경우 타입을 나타내는 데 사용된다.\n\n여기서 타입이란 **이더넷 프레임이 어떤 정보를 캡슐화 하였는지**를 나타내는 정보로 **이더타입** 이라고도 부른다.\n대표적으로 상위 계층에서 사용된 프로토콜의 이름이 명시된다.\n![대표적인 이더타입들](Eth_type_1.png)\n\n### 데이터\n**데이터**는 상위 계층에서 전달받거나 상위 계층으로 전달해야 할 내용이다. 네트워크 계층의 데이터와 헤더를 합친 PDU가 이곳에 포함된다. 최대 크기는 1500바이트 이고, 반드시 일정 크기(46바이트 이상)여야 한다는 점이다.\n만약 데이터가 그 이하의 크리라면, 보통 46바이트 이상이 될 때까지 0으로 채워진다. 여기서 채워진 정보를 **패딩**이라고 한다.\n\n### FCS\n**FCS(Frame Check Sequence)**는 수신한 이더넷 프레임에 오류가 있는지 확인하기 위한 필드이다.\n\nFCS필드에는 **CRC(Cyclic Redundancy Check, 순환 중복 검사)** 라고 불리는 오류 검출용 값이 들어간다. 송신지는 프리앰블을 제외한 나머지 필드값을 바탕으로 CRC 값을 계산한 후, 이 값을 FCS 필드에 명시하면 수신지는 프리앰블과 FCS 필드를 제외한 나머지 필드 값들을 바탕으로 CRC 값을 계산한 뒤, FCS 필드 값과 비교한다. 만약 비교 값이 일치하지 않는다면 프레임에 오류가 있다고 판단하여 해당 프레임을 폐기한다.\n![프레임 검증 과정](Eth_crc_1.png)\n\n> 이더넷 이외의 기술로 **토큰 링** 이라는게 있다."},{"excerpt":"이 글은 혼자 공부하는 네트워크를 보고 이해한 내용을 작성하였다. 컴퓨터 네트워크 시작하기 먼저 네트워크란 무엇이고, 네트워크와 인터넷의 차이점에 대해 알아보겠다. : 여러개의 장치(데스크톱, 노트북, 스마트폰 등)가 마치 그물처럼 서로 연결되어 정보를 주고 받을 수 있는 통신망. : 네트워크를 통해 서로 연결된 장치 뿐만 아니라 지구 반대편에 있는 장치…","fields":{"slug":"/StartNetwork/"},"frontmatter":{"date":"April 15, 2025","title":"컴퓨터 네트워크 찍어먹기","tags":["Network","네트워크-기초"]},"rawMarkdownBody":"이 글은 [혼자 공부하는 네트워크](https://product.kyobobook.co.kr/detail/S000212911507)를 보고 이해한 내용을 작성하였다.\n\n## 컴퓨터 네트워크 시작하기\n먼저 네트워크란 무엇이고, 네트워크와 인터넷의 차이점에 대해 알아보겠다.\n\n`컴퓨터 네트워크(네트워크)`: 여러개의 장치(데스크톱, 노트북, 스마트폰 등)가 마치 그물처럼 서로 연결되어 정보를 주고 받을 수 있는 통신망.\n\n`인터넷`: 네트워크를 통해 서로 연결된 장치 뿐만 아니라 지구 반대편에 있는 장치와 정보를 주고 받을 수 있도록 하는 네트워크. **\"네트워크의 네트워크\"**\n\n네트워크를 `장치`를 연결하는 통신망, 인터넷은 `네트워크`를 연결하여 네트워크 끼리 정보를 주고 받게 한다는 점에서 차이가 있다.\n\n## 네크워크 거시적으로 살펴보기\n네트워크는 여러 장치가 서로 연결하여 정보를 주고 받을 수 있는 통신망이기 때문에, 이 모양을 그래프로 표현 가능하다.\n그래프의 노드는 장치, 간선은 각 장치의 연결 관계를 나타낸다고 생각하면 된다.\n### 네트워크의 기본 구조\n모든 네트워크는 `노드`, 노드를 연결하는 `간선`, 노드간 주고 받는 `메시지`로 구성된다.\n![네트워크의 구성 요소를 그래프로 볼 수 있다](Network_graph.png)\n\n#### 호스트\n네크워크의 가장자리에 위치한 노드를 호스트라고 한다. 호스트는 서버, 데스크톱, 노트북 등이 될 수 있으며 최초로 정보를 생성 및 송신하고 최종적으로 수신한다. 호스트는 특정 역할에 따라 `서버`와 `클라이언트`로 구분할 수 있다.\n\n`서버`: 어떤 서비스를 제공하는 호스트 (파일 서버, 웹 서버, 메일 서버)\n\n`클라이언트`: 서버에세 어떠한 서비스를 요청하고 서버의 응답을 제공받는 호스트\n\n#### 네트워크 장비\n네트워크의 가장자리에 위치하지 않는 중간 노드, 즉 호스트 간 주고받을 정보가 중간에 거치는 노드 호스트 간 주고 받는 정보가 원하는 수신지까지 안정적이고 안전하게 전송될 수 있도록 한다. 이더넷, 허브, 스위치, 라우터, 공유기 등이 있다.\n\n>#### 호스트, 네트워크 장비, 서버, 클라이언트는 완전히 베타적인 개념이 아니다!\n>위와 같은 개념들은 노드의 역할에 따라 구분한 기준에 불과하다는 것에 유의해야 한다. 호스트가 네트워크 장비의 역할을 할 수도 있고, 클라이언트가 서버의 역할을 수행할 수 도 있다는 것이다.\n>이러한 역할의 노드가 있다~ 정도로 이해하는 것이 좋다.\n\n#### 통신 메체\n호스트와 네트워크 장비를 유무선 메체를 통해 연결하는 간선을 통신 매체라고 한다. 통신 메체에는 `유선 매체`와 `무선 매체`가 있다. 말 그대로 무선와 유선의 차이이다.\n\n#### 메시지 \n통신 메체로 연결된 노드가 **주고받는 정보**를 `메시지`라고 한다. 메시지는 파일, 메일 혹은 웹 페이지 등 여러 종류가 될 수 있다.\n\n### 범위에 따른 네트워크 분류\n네크워크는 형성된 범위에 따라 분류하는 기준이 존재한다. 크게 `LAN`과 `WAN`으로 구분하며, 그외 `CNA`과 `MAN`이라는 기준도 존재한다.\n\n#### LAN(Local Area Network)\n가까운 지역을 연결한 **근거리 통신망**을 의미한다. 가정, 학교, 기업처럼 한정된 공간의 네트워크를 `LAN`이라 할 수 있다.\n\n#### WAN(Wide Area Network)\n먼 지역을 연결하는 `광역 통신망`을 의미한다. 멀리 떨어진 LAN, 다시 말해 다른 소속의 LAN들이 통신할 수 있도록 하는 역할이다. 앞서 설명한 인터넷이 바로 이 `WAN`이다.\n\n`WAN`은 ISP(인터넷 서비스 업체)가 구축하고 관리하며, 우리는 ISP에 통신비를 지불하여 인터넷을 사용한다.\n한국의 대표적인 ISP는 KT, LG유플러스, SK브로드밴드 등이 있다.\n\n>  #### CNA과 MAN\n> CNA(Campus Area Network)과 MAN(Metropolitan Area Network)은 LAN과 WAN의 사이에 있는 기준이다.\n> \n> `WAN` > `MAN` > `CAN` > `LAN`\n\n### 메시지 교환 방식에 따른 네트워크 분류\n호스트들이 네트워크를 통해 효율적으로 메시지를 주고 받기 위해, 대표적으로 회선 교환 방식과 패킷 교환 방식을 사용한다.\n\n#### 회선 교환 방식\n![빨간 선이 연결된 회선이다](Network_red_line.png)\n메시지 전송로인 `회선`을 설정하고, 이를 통해 메시지를 주고받는 방식이다. \"회선을 설정한다\"라는 의미는 메시지를 주고 받기 전, 두 호스트 사이를 연결할 회선을 먼저 확보한다는 의미이다.\n\n호스트간 회선을 적절하게 설정하기 위해 **회선 스위치**라는 회선 교환 네트워크 장비를 사용한다.\n\n**장점**\n- 두 호스트 사이에 연결을 확보한 후 메시지를 주고 받기 때문에 주어진 시간동안 전송되는 정보의 양이 비교적 일정하다.\n\n**단점**\n- 회선의 이용 효율이 낮아질 가능성이 있다.\n\n#### 패킷 교환 방식\n![](Network_packet.png)\n메시지를 `패깃`이라는 작은 단위로 쪼개어 전송한다. `패킷`은 교환 네크워크 상에서 송수신되는 메시지의 단위이다.\n\n패킷 교환 방식은 정해진 경로만으로 메시지를 송수신 하지 않기 때문에 최적의 경로를 결정하고 패킷 송수신지를 식별해야 한다. 이를 위해 `라우터`와 `스위치` 같은 **패킷 스위치 네크워크 장비**를 사용한다.\n\n> #### 패킷의 구성\n> 네트워크의 패킷은 `페이로드`, `헤더`, `트레일러`로 구성되어 있다.\n> \n> 페이로드는 전송하고자 하는 데이터, 헤더와 트레일러는 부가 정보 또는 제어 정보가 들어있다.\n\n### 주소와 송수신지 유형에 따른 전송방식\n패킷에 담기는 대표적인 정보로는 `주소`가 있다. `주소`는 송수신지를 특정하는 정보를 의미한다. IP 주소 혹은 MAC 주소가 여기에 포함된다.\n\n그리고 이런 송수신지를 특정할 수 있는 주소가 있다면, 송수신지 유혀엥 따라 다양한 방식으로 메시지를 보낼 수 있다. \n\n`유니캐스트`: 하나의 수신지에 메시지를 전송하는 방식 (1 : 1)\n\n`브로드개스트`: 자신을 제외한 네트워크상의 모든 호스트에게 전송하는 방식. 브로드캐스트가 전송되는 범위를 **브로드캐스트 도메인** 이라고 한다.\n\n`멀티캐스트`: 네트워크 내의 동일 그룹에 속한 호스트에게만 전송하는 방식\n\n`애니캐스트`: 네크위크 내의 동일 그룹에 속한 호스트 중 가장 가까운 호스트에게 전송하는 방식\n\n## 네크워크 미시적으로 살펴보기\n\n### 프로토콜\n노드 간에 정보를 올바르게 주고받기 위해 합의된 규칙이나 방법을 의미한다.\n\n네트워크 상의 노드는 수많은 종류의 통신 장비들로 이루어져 있는데, 각 장비가 요구하는 정보의 형식이 다르다면 원활한 통신이 불가능 할 것이다. 그래서 네트워크에서는 `프로토콜` 이라는 약속을 통해 원활한 통신을 가능하게 한다.\n![HTTP, FTP, TCP, UDP등의 여러 프로토콜이 있다](Network_protocol.png)\n\n### 네트워크 참조 모델\n네크워크로 메시지를 송수신 하는 과정에서 정형화된 여러 단계를 거치게 된다. 이 과정을 계층으로 나눈 구조들을 `네크워크 참조 모델` 또는 `네트워크 계층 모델`이라고 한다.\n네크워크 참조 모델을 사용하면 구성과 설계와 네크워크 문제 진단 및 해결에 용이한 장점이 있다.\n\n#### OSI 모델\n국제 표준화 기구에서 만든 네트워크 참조 모델이다. 통신 단계를 7계층으로 나눠 표현한다.\n![OSI 7계층](Network_OSI_7.png)\n\n1. **물리 계층**\n\t- \b최하단 계층으로, 1과 0으로 표현되는 비트 신호를 주고 받는 계층\n2. **데이터 링크 계층**\n\t- 네크워크 내 주변 장치 간의 정보를 주고 받기위한 계층\n3. **네크워크 계층**\n\t- 메시지를 다른 네트워크에 속한 수신지까지 전달하는 계층\n4. **전송 계층**\n\t- 신뢰성 있고 안전성 있는 전송을 해야 할 때 필요한 계층\n5. **세션 계층**\n\t- 통신을 주고 받는 호스트의 응용 프로그램 간 연결 상태를 관리하기 위한 계층\n6. **표현 계층**\n\t- 사람이 이해할 수 있는 언어인 문자를 컴퓨터가 이해할 수 있는 코드로 변환, 압축, 암호화 작업하는 계층\n7. **응용 계층**\n\t- 최상단 계층으로, 사용자가 이용할 응용 프로그램에 다양한 네트워크 서비스를 제공하는 계층\n\n#### TCP/IP 모델\n앞서 본 OSI 모델은 주로 네크워크를 이론적으로 기술할 때 사용하는 반면, `TCP/IP 모델`은 구현에 중점을 둔 모델이다. \n![TCP/IP 모델](Network_TCPIP_4.png)\n1. **네트워크 엑세스 계층**\n\t- 링크 계층 또는 네트워크 인터페이스 계층이라고도 불리며, OSI 모델의 데이터 링크 계층과 유사\n2. **인터넷 계층**\n\t- OSI 모델의 전송 계층과 유사\n3. **전송 계층**\n\t- OSI 모델의 전송 계층과 유사 \n4. **응용 계층**\n\t- OSI 모델의 세션 계층, 표현 계층, 응용 계층을 합친 것과 유사\n\n### 캡슐화와 역캡슐화\n패킷의 송신 과정에서 캡슐화가 이루어 지고, 수신 과정에서 역캡슐화가 이루어 진다. 이는 네크워크 참조 모델의 계층 관점에서 봤을 때 송신의 경우 가장 높은 계층에서 낮은 계층으로, 수신은 가장 낮은 계층에서 높은 계층으로 이동하는 것을 알 수 있다. \n![메시지의 송수신 양상을 잘 기억하자](Network_Cap_1.png)\n#### 캡슐화\n송신 과정에서 헤더 및 트레일러를 추가해 나가는 과정을 말한다.\n한 단계 아래 계층은 바로 위의 계층으로 부터 받은 패킷에 헤더 및 트레일러를 추가한다.\n![캡슐화 하며 헤더와 트레일러가 추가되는 모습](Network_Cap_t.png)\n#### 역캡슐화\n캡슐화의 반대 작업이다. 수신할 때 캡슐화 과정에서 붙였던 헤더 및 트레일러를 각 계층에서 확인 뒤 제거하는 과정이다. \n![역캡슐화로 헤더와 트레일러가 제거되는 모습](Network_Cap_f.png)\n#### PDU\n각 계층에서 송수신되는 메시지의 단위를 **PDU(Protocol Data Unit)** 라고 한다. 아래는 각 계층에 대한 PDU이다.\n![각 계층별 PDU](Network_PDU.png)\n\n> 전송 계층의 PDU는 TCP 프로토콜이 사용되었을 경우 세크먼트, UDP 프로토콜이 사용되었을 경우 데이터그램이 된다.\n\n![지금까지의 내용들을 시각화한 자료](Network_total.png)\n> ### ‼️ OSI 7계층, TCP/IP 계층은 사실 아무것도 해주지 않는다!\n> 네트워크 참조 모델에 근거하여 반드시 특정 계층에 완벽하게 대응될 것이라 오해할 수 있는데, 말 그대로 **\"참조 모델\"** 이기 때문에 네트워크 구조에 대한 개념 참조를 위해 사용하는 것이 바람직 하다.\n> \n> 지금도 새로운 프로토콜 혹은 네트워크 장비들이 나오고 있는데, 모든 프로토콜이나 장비들이 특정 계층에 완벽하게 대응하지는 않는다. \n> \n> 그러니 네크워크 참조 모델이나 특정 계층은 **네트워크를 작동시키는 주체나 반드시 지켜야 하는 \"규칙\"이 아닌** 그저 **\"모델\"** 이라는 걸 잘 기억해 두어야 한다."},{"excerpt":"가끔 개발하다 보면, 검색 기능이나 어떤 문자열에 사용자가 검색을 할 때 개발자의 의도와는 다르게 문장을 입력할 때가 있다.\n예를들어...  \"   검색     \" \"검     색       \" 위와 같이 필요없는 앞 뒤 공백이나 줄바꿈이 들어간 문자열을 예쁘게 다듬어 주는 기능을 trim이라고 한다. 여담으로 trim은 어떤 것을 정리하거나 잘라내는 작…","fields":{"slug":"/TrimString/"},"frontmatter":{"date":"April 01, 2025","title":"Swift에서 문자열 예쁘게 만들기","tags":["trim","Swift","iOS"]},"rawMarkdownBody":"\n가끔 개발하다 보면, 검색 기능이나 어떤 문자열에 사용자가 검색을 할 때 개발자의 의도와는 다르게 문장을 입력할 때가 있다.\n예를들어... \n- \"   검색     \"\n- \"검     색       \"\n\n위와 같이 필요없는 앞 뒤 공백이나 줄바꿈이 들어간 문자열을 예쁘게 다듬어 주는 기능을 trim이라고 한다.\n> 여담으로 trim은 어떤 것을 정리하거나 잘라내는 작업이나 과정을 뜻하는 단어이다.\n\n### Swift에서 trim사용하기\nSwift에서는 **`trimmingCharacters(in:)`** 을 사용하여 문자열을 정리할 수 있다.\n`in:` 에는 `CharacterSet`이라는 타입을 넣는데, 주로 `.whitespaces`를 사용하는 것 같다.\n\n| **CharacterSet 종류**       | **설명**                                                       |\n| ------------------------- | ------------------------------------------------------------ |\n| `.whitespaces`            | 문자열의 앞과 뒤에서 **공백 문자**(`\" \"`, `\"\\t\"`, `\"\\n\"`, `\"\\r\"`)를 제거합니다. |\n| `.whitespacesAndNewlines` | 문자열의 앞과 뒤에서 **공백 문자**와 **새 줄 문자**(`\"\\n\"`, `\"\\r\"`)를 제거합니다.    |\n| `.decimalDigits`          | 문자열의 앞과 뒤에서 **숫자**(`0-9`)를 제거합니다.                            |\n| `.letters`                | 문자열의 앞과 뒤에서 **알파벳 문자**(대소문자 포함)를 제거합니다.                      |\n| `.lowercaseLetters`       | 문자열의 앞과 뒤에서 **소문자 알파벳 문자**(`a-z`)를 제거합니다.                    |\n| `.uppercaseLetters`       | 문자열의 앞과 뒤에서 **대문자 알파벳 문자**(`A-Z`)를 제거합니다.                    |\n| `.nonBaseCharacters`      | 문자열의 앞과 뒤에서 **기저가 아닌 문자**(주로 글자 위에 표시되는 문자들)을 제거합니다.         |\n| `.punctuationCharacters`  | 문자열의 앞과 뒤에서 **구두점 문자**(`\"!\"`, `\"#\"`, `\"$\"`, `\"%\"` 등)을 제거합니다. |\n| `.symbols`                | 문자열의 앞과 뒤에서 **기호 문자**(`@`, `&`, `*`, `+` 등)을 제거합니다.          |\n| `.alphanumerics`          | 문자열의 앞과 뒤에서 **알파벳 문자**와 **숫자**만 남기고, 나머지 문자를 제거합니다.          |\n| `.urlHostAllowed`         | URL의 호스트 이름에 **허용되는 문자**(주로 도메인 이름에 사용되는 문자)를 제외한 문자를 제거합니다. |\n| `.urlPathAllowed`         | URL 경로에서 **허용되는 문자**(경로의 일부로 사용될 수 있는 문자)를 제외한 문자를 제거합니다.    |\n| `.urlQueryAllowed`        | URL 쿼리에서 **허용되는 문자**(쿼리 파라미터에 사용할 수 있는 문자)를 제외한 문자를 제거합니다.   |\n| `.urlFragmentAllowed`     | URL 프래그먼트에서 **허용되는 문자**를 제외한 문자를 제거합니다.                      |\n| `.controlCharacters`      | 문자열의 앞과 뒤에서 **제어 문자**(C0 제어 문자 등)를 제거합니다.                    |\n| `.newlines`               | 문자열의 앞과 뒤에서 **새 줄 문자**(`\\n`, `\\r`)를 제거합니다.                   |\n|                           |                                                              |\n\n아래와 같이 사용 가능하다.\n``` swift\nlet uglyString = \" i'm String.  \"\nlet prettyString = uglyString.trimmingCharacters(in: .whitespaces) // 앞뒤 공백 제거하기\n\nprint(prettyString) // i'm String.\n```\n\n### 참고\n- https://m.blog.naver.com/traeumen927/221233934563\n"},{"excerpt":"개인 프로젝트 개발중, 분명 메모리 해제가 되어야 하는 객체가 중첩돼서 메모리를 잡아먹는 현상이 발생하였다.\n이런 현상을 메모리 릭(Memory Leak) 이라고 하는데, 어떻게 메모리 릭이 일어났는지 확인하고 해결하였는지에 대한 과정을 기록해 볼까 한다. 메모리 릭 찾기 처음 메모리 릭이 생겼다는걸 발견한건 Rxswift를 사용하여 구독한 Observa…","fields":{"slug":"/FixMemoryLeak/"},"frontmatter":{"date":"March 27, 2025","title":"메모리 릭 잡고 성능 최적화하기","tags":["메모리 릭","iOS"]},"rawMarkdownBody":"\n개인 프로젝트 개발중, 분명 메모리 해제가 되어야 하는 객체가 중첩돼서 메모리를 잡아먹는 현상이 발생하였다.\n이런 현상을 **메모리 릭(Memory Leak)** 이라고 하는데, 어떻게 메모리 릭이 일어났는지 확인하고 해결하였는지에 대한 과정을 기록해 볼까 한다.\n\n### 메모리 릭 찾기\n처음 메모리 릭이 생겼다는걸 발견한건 Rxswift를 사용하여 구독한 Observable이 화면이 사라졌음에도 불구하고 dispose가 되지 않는 것을 확인했을 때이다.\n``` swift\nNotificationCenter.keyboardHightObservable\n\t.debug()\n\t.skip(while: { $0 == 0.0 })\n\t.subscribe(onNext: setNextButtonPosition)\n\t.disposed(by: disposeBag)\n\n// setNextButtonPosition 함수\nprivate func setNextButtonPosition(keyboardHeight: CGFloat) {\n\tprint(keyboardHeight)\n\n\t// 다른 코드들...\n}\n```\n해당 코드에서 `NotificationCenter.keyboardHightObservable`은 키보드가 보이고 사라질 때, 키보드의 높이를 이벤트로 방출하는 Observable이고, 그 Observable을 구독하여 `setNextButtonPosition(:_)`이라는 함수를 실행시키는 코드이다.\n\n`setNextButtonPosition(:_)`는 `keyboardHeight`를 받아 print를 하는데, 해당 출력이 화면을 보여줄때마다 중첩해서 출력되는 현상이 발생하였다.\n\n![메모리 릭이 발상하는 모습](flow-memory-leak-v1.gif)\n\n\n좀더 확실하게 확인하기 위해 Xcode의 성능 분석 도구를 사용해 보았다.\n**Product > Profile** 또는 **Command + i** 를 사용하여 프로파일 도구를 실행시키고, **Leaks** 항목을 선택한다.\n\n그 다음 화면의 **오른쪽 위 빨간색 재생 버튼**같이 생긴걸 누르면, 앱이 실행되면서 검사를 시작하게 된다.\n![메모리 릭 테스트](flow-memory-leak-test.gif)\n검사중인 화면에서 **Leaks** 라는 부분을 보면 메모리 릭이 있는지 체크표시로 표시해 준다. 예상대로 특정 화면을 열고 닫는 과정 중 메모리 릭이 일어나 표시해 주는 것을 확인할 수 있다.\n\n## 해결하기\n메모리 릭이 일어나는 이유는 아래와 같이 여러 요인들이 있다.\n- 순환 참조\n- 강한 참조\n- 뷰 컨트롤러의 라이프 사이클 관리 실수\n- 클로저에서의 강한 참조\n\n저 많은 요인들중 가장 의심가는 문제는 `.subscribe(onNext:_)`의 클로저에서 `setNextButtonPosition` 을 강한 참조로 실행시킨 부분이다. 사실 이 부분은 RxSwift를 사용하면서 가장 흔하게 생기는 문제인데, `.subscribe(onNext: setNextButtonPosition)`형식으로 바로 사용하면 문제가 생기지 않을거라고 생각한 내 실수였다.\n\n해당 문제를 해결하는 방법은 간단하게 강한 참조를 weak self를 사용하여 약한 참조로 바꾸는 것이다.\n```swift\nNotificationCenter.keyboardHightObservable\n\t.skip(while: { $0 == 0.0 })\n\t.subscribe(onNext: { [weak self] in\n\t\tguard let self else { return }\n\t\tsetNextButtonPosition(keyboardHeight: $0)\n\t})\n\t.disposed(by: disposeBag)\n```\n\n마지막으로 성능도구 확인까지 해보자\n![해결된 메모리 릭](flow-memory-leak-last.gif)"},{"excerpt":"iOS를 개발하다 보면, 색상에 관련된 UIColor과 cgColor에 대해 본적이 있을 것이다. 과연 이둘은 뭐가 다르고 무슨 차이점이 있는걸까? 공식 문서의 설명을 보면, \nUIColor은 색상 데이터와 불투명도를 지정하는 개체,\nCGColor은 색상 해석 방법을 지정하는 색상 공간과 함께 색상을 정의하는 구성요소 집합\n이라고 한다. 그냥 말로만 봤을…","fields":{"slug":"/UIColorAndCGColor/"},"frontmatter":{"date":"March 22, 2025","title":"UIColor과 CGColor은 뭐가 다른걸까","tags":["iOS","UIKit","Core Graphics","Color"]},"rawMarkdownBody":"\niOS를 개발하다 보면, 색상에 관련된 UIColor과 cgColor에 대해 본적이 있을 것이다. 과연 이둘은 뭐가 다르고 무슨 차이점이 있는걸까?\n\n공식 문서의 설명을 보면, \nUIColor은 색상 데이터와 불투명도를 지정하는 개체,\nCGColor은 색상 해석 방법을 지정하는 색상 공간과 함께 색상을 정의하는 구성요소 집합\n이라고 한다.\n\n그냥 말로만 봤을때, 둘다 색상에 관련된 무언가 라는건데..\n이둘의 확실한 차이점은 파생된 부분에서 확인할 수 있다.\n\n| UIkit > UIColor       | Core Graphics > CGColor |\n| :---------------------: | :-----------------------: |\n| ![](UIColor_path.png) | ![](CGColor_path.png) |\nUIColor와 CGColor은 파생된 프레임워크가 다르다는 것을 알 수 있다.\n\n그럼 CGColor가 파생된 저 Core Graphics는 과연 무엇일까?\n\n[문서](https://developer.apple.com/documentation/coregraphics)에 따르면 Core Graphics는 iOS의 그래픽 렌더링 프레임워크로, 2D 그래픽을 다루는데 사용된다고 한다. Quartz라는 고급 그리기 엔진을 기반으로 다양한 그래픽 관련 작업을 표율적으로 처리할 수 있도록 돕는다고 한다.\n\nUIkit과  Core Graphics의 차이점은 아래와 같다.\n\n| 특징       |                         UIkit                         |                 Core Graphics                 |\n| -------- | :---------------------------------------------------: | :-------------------------------------------: |\n| 목적       |                  UI 구성 및 사용자 상호작용 관리                  |            저수준 2D 그래픽 렌더링 및 그래픽 처리            |\n| 사용되는 곳   |               사용자 인터페이스(UI) 및 애니메이션 관리                |       이미지, 그리기, 색상, PDF 생성 및 고급 그래픽 작업        |\n| 주요 객체    | `UIView`, `UIViewController`, `UIButton`, `UILabel` 등 | `CGContext`, `CGColor`, `CGPath`, `CGImage` 등 |\n| 주요 기능    |           UI 요소 관리, 사용자 입력 처리, 화면 전환, 애니메이션           |       2D 그래픽 그리기, 색상 관리, 이미지 처리, PDF 처리       |\n| 성능 및 최적화 |               고수준 UI 구성 요소, 사용자 편의성 중점                |              성능 최적화 및 메모리 효율성 중점              |\n| 사용 시점    |              앱의 UI 구성 및 사용자 인터페이스 관리에 사용              |        2D 그래픽 작업이나 커스텀 UI 요소를 그릴 때 사용         |\n| 주요 사용 예시 |              버튼, 레이블, 텍스트 필드 등 UI 요소 생성               |           도형 그리기, 이미지 렌더링, PDF 생성 등           |\n\n**색상을 UI에서 사용할 때는 UIColor을, 그래픽 작업에서 색상을 다룰 때는 CGColor을 사용한다!** 라고 생각하면 될 것 같다."},{"excerpt":"웹을 개발하다 보면, SEO라는 용어를 자주 접하게 된다. 과연 SEO란 무엇이고, 왜 이 SEO를 잘 해야하는지 알아보자. 노출을 위한 최적화, SEO SEO는 검색 엔진 최적화(Search Engine Optimization)의 약자로, 우리가 주로 검색하는 Google이나 Naver의 검색 알고리즘에서 상위 사이트로 노출되기 위한 작업이다. 만약 내…","fields":{"slug":"/SEO/"},"frontmatter":{"date":"March 13, 2025","title":"SEO 파먹기","tags":["SEO 최적화","최적화","Frontend"]},"rawMarkdownBody":"\n웹을 개발하다 보면, SEO라는 용어를 자주 접하게 된다. 과연 SEO란 무엇이고, 왜 이 SEO를 잘 해야하는지 알아보자.\n\n## 노출을 위한 최적화, SEO\nSEO는 검색 엔진 최적화(Search Engine Optimization)의 약자로, 우리가 주로 검색하는 Google이나 Naver의 검색 알고리즘에서 상위 사이트로 노출되기 위한 작업이다.\n\n만약 내가 사과 농장을 운영하고 있고, 이런 사과를 팔기 위한 사이트를 배포했다 하였을 때, \"사과\" 또는 \"사과 구입\" 등과 같은 검색 키워드로 상위에 노출되고 싶다면 그에 맞는 SEO작업을 진행하여 구매자의 진입률을 높이고 최종적으로 수입까지 높일 수 있는 것이다.\n\nSEO최적화만 잘 한다면 직접적으로 노출건수(클릭 건수)가 늘어 많은 이익을 얻을 수 있어, 다소 시간이 걸리지만 꼭 해줘야 하는 작업이다.\n\n## SEO 최적화를 위한 방법\n어떤 방법을 사용해야 SEO최적화를 할 수 있을까?\n\n![](SimTagEx.png)\n첫번째 방법은 \"시맨틱 태그\"를 사용하여 웹사이트를 구성하는 것이다. \n시맨틱 태그란 포함된 콘텐츠의 특정 의미를 정의하고 목적을 갖는 태그로 HTML5에서 처음 등장하였다. 흔히들 div나 span태그만 사용한 구성을 사용하여 웹사이트를 개발하는데, 이 시맨틱 태드를 사용하면 각 콘텐트의 역할 구분이 명확해 지면서 검색엔진이 페이지를 효율적으로 분석할 수 있게 된다. 결과적으로 SEO에 도움이 되는 것이다. 추가로 구글의 랭킹 알고리즘은 명확한 콘텐츠의 구조로 인해 신뢰도가 높다고 판단하여 더 높은 랭킹에 사이트를 올릴 수도 있다고 한다.\n\n\n<center><img src=\"MetaTagEx.png\"/></center>\n두번째 방법은 \"메타 태그\"를 명시해주는 방법이다.\n메타 태그란 웹페이지의 메타데이터(페이지 설명, 키워드, 작성자 정보 등)을 제공하는 HTML 태그이다. 메타 태그 직접적으로 웹사이트에 영향을 주는 부분은 없지만, 검색 엔진이나 해당 페이지를 들어가지 않은 상태에서 뜨는 회부 시스템에 정보를 전달해 주는 역할을 한다. 카카오톡이나 페이스북에 링크를 공유했을 때 뜨는 미리보기 배너를 본적이 있을텐데, 그런 부분들도 모두 meta태그로 구성된 정보를 가져와 띄우는 것이다. (해당 기능은 메타 태그의 오픈 그래프(og)라고 불린다.)\n\n메타 태그의 대표적인 사용 방법은 웹페이지의 head 섹션에 아래 코드들을 원하는 사이트(페이지)의 컨셉에 맞춰 작성하는 것이다.\n```html\n<meta name=\"description\" content=\"이 웹사이트는 SEO 최적화에 대한 다양한 정보를 제공합니다.\">\n\n<meta name=\"keywords\" content=\"SEO, 최적화, 검색 엔진, 키워드 연구\">\n\n<meta name=\"author\" content=\"홍길동\">\n\n<meta property=\"og:title\" content=\"SEO 최적화 방법\">\n<meta property=\"og:description\" content=\"SEO 최적화의 중요성과 팁을 알아보세요.\">\n<meta property=\"og:image\" content=\"https://example.com/image.jpg\">\n```\n이외 더 다양한 메타 태그는 [여기](https://www.w3schools.com/tags/tag_meta.asp)를 참고하자\n\n세번째 방법은 \"사이트맵(Sitemap)\"을 만들어 웹페이지에 적용하는 것이다.\n사이트맵이란, 웹사이트의 구조를 나타내는 파일로, 웹사이트의 페이지들이 어떻게 연결되어 있는지에 대한 정보를 제공하는 XML형식의 파일이다. 해당 파일을 만드는 방법은 [사이트맵을 만들어주는 사이트](https://www.xml-sitemaps.com/)에 들어가 자동으로 만들거나, 자체적인 라이브러리를 사용하거나, 직접 작성하는 방법 등이 있다. 사이트맵을 적용하게 되면 검색 엔진 크롤러가 해당 사이트맵을 참고하여 효율적으로 모든 페이지를 크롤링 하게 된다.\n\n또 구글이나 네이버의 경우, 사이트맵을 제출하여 색인 작업을 진행할 수도 있다.\n\n\n### 참고자료\n- https://library.gabia.com/contents/domain/4359/\n- https://www.w3schools.com/tags/tag_meta.asp\n- https://seo.tbwakorea.com/blog/seo-guide-2022/\n"},{"excerpt":"CORS는 프론트엔드 개발을 할때, 누구나 한번쯤 본적 있는 오류라고 할 만큼 자주 발생하는 오류이다. 그렇다면, CORS란 무엇이고 왜 발생하며, 어떻게 해결해야 할까? 1. CORS란? CORS란 Cross-Origin Resource Sharing의 약자로 직역하면 \"교차 출처 리소스 공유 정책\" 이라 해석할 수 있다. 여기서 교차란, 엇갈린 다른 …","fields":{"slug":"/Cors/"},"frontmatter":{"date":"February 03, 2025","title":"CORS 알아보기","tags":["CORS"]},"rawMarkdownBody":"\n- CORS는 프론트엔드 개발을 할때, 누구나 한번쯤 본적 있는 오류라고 할 만큼 자주 발생하는 오류이다.\n- 그렇다면, CORS란 무엇이고 왜 발생하며, 어떻게 해결해야 할까?\n\n## 1. CORS란?\n- CORS란 **Cross-Origin Resource Sharing**의 약자로 직역하면 \"교차 출처 리소스 공유 정책\" 이라 해석할 수 있다.\n- 여기서 교차란, 엇갈린 다른 출처를 의미한다.\n- 그렇다면 **교차 출처 리소스**의 출처란 무엇일까?\n### 1-1. 출처(Origin)\n- 우리가 웹 사이트에 접근할때, URL이라는 문자열을 사용하여 접근하게 된다.\n- 이런 URL의 구성 요소는 아래와 같다.\n![](URL_ex.png)\n- Protocol(Scheme): http, https\n- Host: 사이트 도메인\n- Port: 포트 번호\n- Path: 가이트 내부 경로\n- Query string: 요청의 key와 value값\n- Fragment: 해시 태그\n\n- 여기서 Origin은 **Protocol + Host + Port** 라고 할 수 있다.\n### 1-2. 동일 출처 정책 (Same-Origin Prolicy)\n- 이제 출처(Origin)이 뭔지 알게 되었으니, Same Origin 정책과 Cross Origin 정책에 대해 알아보자.\n\n- SOP는 **동일한 출처에 대한 정책**을 의미한다. 이 SOP 정책은 \"동일한 출처에서만 리소스를 공유할 수 있다\" 라는 법률을 가지고 있다.\n- 즉 동일 출처(Same-Origin)서버에 있는 리소스는 자유롭게 가져올 수 있지만, 다른 출처(Cross-Origin)서버에 있는 이미지나 기타 리소스들은 상호작용이 불가능 하다는 말이다.\n#### 1-2-1. 동일 출처 정책이 필요한 이유\n- 만일, 동일한 출처가 아닌 다른 출처의 리소스를 자유롭게 사용 가능하다면, CSRF나 XSS 등의 방법으로 우리가 만들 어플리케이션에 해커가 심어놓은 코드가 실행하여 정보를 가로챌 수 있다.\n- 그렇기 때문에 SOP 정책으로 동일하지 않는 다른 출처의 스크립트가 실행되지 않도록 브라우저에서 사전에 미리 방지하는 것이다.\n### 1-3. 같은 출처와 다른 출처의 구분 기준\n- SOP 정책에서 같은 출처(Origin)의 판단 기준은 무엇일까?\n- 동일한 출처의 기준은 URL의 구성 요소 중 **Protocol(Scheme), Host, Port** 3가지만 동일하다면, 동일한 출처로 판단한다.\n\n- 다음은 https://www.hello.com:3000 출처에 대한 URL에 따른 동일 출처 비교표이다.\n\n|                 **URL**                 | **동일 출처인가?** |           이유            |\n| :-------------------------------------: | :----------: | :---------------------: |\n|    https://www.hello.com:3000/about     |     true     |   프로토콜, 호스트, 포트 번호 동일   |\n| https://www.hello.com:3000/about?page=1 |     true     |   프로토콜, 호스트, 포트 번호 동일   |\n|        http://www.hello.com:3000        |    false     | 프로토콜 다름 (http != https) |\n|        https://www.hello.kr:3000        |    false     |         호스트 다름          |\n|       https://www.hello.com:8888        |    false     |        포트 번호 다름         |\n|          https://www.hello.com          |    false     |  포트 번호 다름(443 != 3000)  |\n### 1-4. 출처 비교와 차단\n- 그렇다면, 저런 출처의 다름을 판단하고 차단을 진행하는 작업은 어디서 처리되는 것일까?\n- 네트워크에 관련된 오류 이므로 서버에서 처리한다 생각할 수 있겠지만, 이는 **브라우저에서 구현된** 기능이다.\n![](URL_flow.png)\n\n- 서버는 옳바른 응답을 진행 하지만, 동일한 출처를 판단할 헤더 정보가 없을 때 브라우저에서 에러를 발생시키는 것이다.\n- 하지만, 만약 모든 출처가 다른 요청을 막는다면 다른 웹페이지의 리소스를 쓰지 않고 개발을 해야하는 웃지 못할 상황이 생겨날 것이다.\n- 그래서 몇 가지 예외 조항을 두고 다른 출처의 리소스 요청이라도 이 조항에 해당할 경우에는 허용하기로 하는데, 이중 하나가 **CORS 정책**을 지킨 리소스 요청이다.\n## 2. 교차 출처 리소스 공유 (Cross-Origin Resource Sharing)\n- 이처럼 **교차 출처 리소스 공유(CORS)**는 **다른 출처의 리소스 공유에 대한 허용/비허용 정책**이다.\n- 다른 출처의 리소스를 어쩔수 없이 참고해야 하는 상황에서는 이 CORS 정책을 허용하는 리소스에 한에 참고 가능하게 하는 것이다.\n- 결국, CORS는 에러를 이르키는 주범이 라니라, SOP 정책에 따라 다른 출처의 리소스를 차단하면서 발생된 에러를 해결하기 위한 해결책 인것이다.\n### 2-1. 브라우저의 CORS 기본 동작\n##### 1. 클라이언트에서 HTTP 요청을 헤더에 Origin을 담아 전달\n- 기본적으로 웹은 HTTP 프로토콜을 이용하여 서버에 요청을 보내게 된다.\n- 이때 브라우저는 요청 헤더에 Origin이라는 필드에 출처를 함께 담아 보내게 된다.\n![](origin_url.png)\n\n##### 2. 서버는 응답헤더에 Access-Control-Allow-Origin을 담아 클라이언트로 전달한다.\n- 이후 서버가 이 요청에 대한 응답을 할 때 응답 헤더에 `Access-Control-Allow-Origin`이라는 필도를 추가하고 값으로 **이 리소스를 접근하는 것이 허용된 출처 url**을 내려보낸다.\n\n![](aca_url.png)\n\n##### 3. 클라이언트에서 Origin과 서버가 보내준 Access-Control-Allow-Origin을 비교한다.\n- 이후 응답을 받은 브라우저는 자신이 보냈던 요청의 Origin과 서버가 보내준 응답의 Access-Control-Allow-Origin을 비교해본 후 차단할지 말지를 결정한다.\n- 만약 유효하지 않다면 그 응답을 사용하지 않고 버린다. (CORS 에러)\n- 위의 경우에는 둘다 http://localhost:3000 인 유효한 출처의 리소스이기 때문에 에러가 발생하지 않는다.\n\n## CORS 작동 방식 (예비 요청)\n- CORS에는 3가지 작동 방식이 있는데, 그중 하나가 바로 **예비 요청** 방식이다.\n- 예비요청 방식은 브라우저에서 요청을 보낼때, 한번에 요청을 보내는게 아닌 예비 요청을 먼저 보낸 후 통신을 확인 하고 본 요청을 보낸다.\n- 예비 요청을 보냄으로써 안전한지 여부를 브라우저에서 확인하는 것이다.\n- 여기서 예비 요청을 보내는 것을 Preflight라고 부르며, HTTP의 **OPTIONS**라는 메소드를 사용하여 요청한다.\n![](cors_flow.png)\n\n## 참고\n- https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-CORS-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95-%F0%9F%91%8F\n"},{"excerpt":"Create-React-App의 줄임말 이다. 리엑트를 사용하는 프로젝트를 만들 때 도움을 주는 도구이다. 리엑트 앱 생성하기 위 명령어로 생성 가능하다. 생성한 후 vsCode로 열면 여러 파일들이 있을텐데, src 파일로 들어가 와 를 제외한 나마지 파일들은 모두 제거하였다. 1. 컴포넌트 파일로 분리하고 사용하기 컴포넌트를 파일 단위로 분리하여 사용…","fields":{"slug":"/CRA/"},"frontmatter":{"date":"January 24, 2025","title":"CRA","tags":["CRA","React","프로젝트 세팅"]},"rawMarkdownBody":"\n- [Create-React-App](https://create-react-app.dev/)의 줄임말 이다.\n- 리엑트를 사용하는 프로젝트를 만들 때 도움을 주는 도구이다.\n\n## 리엑트 앱 생성하기\n\n```\nnpx create-react-app {원하는 프로젝트 명}\n```\n\n- 위 명령어로 생성 가능하다.\n\n- 생성한 후 vsCode로 열면 여러 파일들이 있을텐데, src 파일로 들어가 `App.js`와 `index.js`를 제외한 나마지 파일들은 모두 제거하였다.\n\n### 1. 컴포넌트 파일로 분리하고 사용하기\n\n- 컴포넌트를 파일 단위로 분리하여 사용하는 기능을 제공한다.\n\n##### 1-1. 컴포넌트 생성\n\n- 먼저 컴포넌트를 만들 파일을 생성해 준다.\n\n![](setting-img.png)\n\n- 그후 아래와 같이 컴포넌트를 만들어 준다.\n\n```js\nconst Button = ({ text }) => {\n  return <button>{text}</button>\n}\n```\n\n- 후에 `export default`를 사용하여 다른 파일에서 컴포넌트를 사용할 수 있도록 해준다.\n\n##### 1-2. 다른 파일에서 사용하기\n\n- 해당 컴포넌트를 사용하는 쪽에서는 `import`를 사용하여 컴포넌트를 받아온 후 사용 가능하다.\n\n```js\nimport Button from \"./Button\"\n\nfunction App() {\n  return (\n    <div>\n      <h1>Hello!</h1>\n      <Button text={\"hello!\"} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n### 2. 컴포넌트 마다 스타일 적용시키기\n\n- 모듈을 파일로 분리 가능하진다면 css 파일로 각 스타일들을 관리할 때, 모든 class 이름을 다르게 만드는 일이 일어날 수 있다.\n- 이를 해결하기 위해 css파일도 모듈마다 적용 시킬 수 있는 기능을 지원한다.\n\n##### 2-1. css 모듈 파일 생성\n\n- 모듈마다의 스타일 적용을 위해 css파일도 각자 만들어 준다.\n- 나같은 경우 `Button.module.css`라는 이름의 파일을 생성해 주었다.\n\n##### 2-2. css 작성하기\n\n- css 파일에 원하는 클래스 명과 스타일 코드를 작성해 준다.\n\n```css\n.btn {\n  background-color: tomato;\n  color: white;\n}\n```\n\n##### 2-3. 스타일 적용하기\n\n- 원하는 모듈 파일로 들어가 아래와 같이 `import` 구문을 작성해준다.\n\n```js\nimport styles from \"./Button.module.css\"\n```\n\n- 그 후, 스타일을 적용할 블럭의 class를 다음과 같이 작성한다.\n\n```jsx\n<button class={styles.btn}></button>\n```\n\n- 이렇게 하면 css에 작성한 스타일이 이 묘듈에만 적용된다.\n"},{"excerpt":"버블링 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작한다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작한다. 위 코드에서 p태그를 누르게 된다면,  >  >  순서대로 이벤트 버블링이 일어나 alert가 출력된다. 이러한 흐름을 \"이벤트 버블링\"이라고…","fields":{"slug":"/BubblingAndCapturing/"},"frontmatter":{"date":"January 24, 2025","title":"버블링과 캡처링","tags":["버블링과 캡처링","JavaScript"]},"rawMarkdownBody":"\n## 버블링\n\n- 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작한다.\n- 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작한다.\n\n```html\n<style>\n  body * {\n    margin: 10px;\n    border: 1px solid blue;\n  }\n</style>\n\n<form onclick=\"alert('form')\">\n  FORM\n  <div onclick=\"alert('div')\">\n    DIV\n    <p onclick=\"alert('p')\">P</p>\n  </div>\n</form>\n```\n\n- 위 코드에서 p태그를 누르게 된다면, `p` > `div` > `form` 순서대로 이벤트 버블링이 일어나 alert가 출력된다.\n- 이러한 흐름을 \"이벤트 버블링\"이라고 부른다.\n\n> `\"거의\"` 모든 이벤트가 버블링이 된다.\n> 여기서 `\"거의\"`가 붙은 이유는 focus와 같은 예외도 있기 때문이다.\n\n## event.target\n\n- 부모 요소의 핸들러는 이벤트가 정확히 어디서 발생했는지 등에 대한 자세한 정보를 얻을 수 있다.\n- 이벤트가 발생한 **가장 안쪽의 요소는 타겟(target)요소**라고 불리고, **event.target을 사용해 접근**할 수 있다.\n- `event.target`과 this(=`event.currentTarget`)는 다음과 같은 차이점이 있다.\n  - `event.target`은 실제 이벤트가 시작된 타깃 요소이다. 버블링이 진행되어도 변하지 않는다.\n  - `this`는 현재 요소로, 현재 실행 중인 핸들러가 할당된 요소를 참조한다.\n\n## 버블링 중단하기\n\n- 이벤트 버블링은 타깃 이벤트에서 시작해서 `<html>`요소를 거쳐 `document` 객체를 만날 때까지 각 노드에서 모두 발생한다. 몇몇 이벤트는 `window` 객체까지 거슬러 올라간다.\n- 핸들러에게 이벤트를 완전히 처리하고 난 후 버블링을 중단하도록 명령할 수 있다.\n- `event.stopPropagation()`를 사용하면 해당 메서드를 사용한 위치부터 버블링이 일어나지 않는다.\n\n## 캡처링\n\n- 이벤트엔 버블링 이외에도 \"캡처링\" 이라는 흐름이 존재한다.\n- 표준 Dom 이벤트에서 정의한 흐름엔 3가지 단계가 있다.\n  1.  캡처링 단계: 이벤트가 하위 요소로 전파되는 단계\n  2.  타깃 단계: 이벤트가 실제 타깃 요소에 전달되는 단계\n  3.  버블링 단계: 이벤트가 상위 요소로 전파되는 단계\n\n![](tree.png)\n\n1. `<td>` 를 클릭하면 이벤트가 최상위 조상에서 시작해 아래로 전파되고(캡처링 단계)\n2. 이벤트가 타깃 요소에 도착해 실행된 후(타깃 단계)\n3. 다시 위로 전파된다. (버블링 단계)\n\n- 이런 과정을 통해 요소레 할단된 이벤트 핸들러가 호출된다.\n\n- `on<event>` 프로퍼티나 HTML 속성, `addEventListener(event, handler)`를 이용해 할당된 핸들러는 캡처링에 대해 전혀 알 수 없다.\n- 캡처링 단계에서 이벤트를 잡아내려면 `addEventListener`의 `capture` 옵션을 `true`로 설정해야 한다.\n\n```js\nelem.addEventListener(..., {capture: true});\n// capture은 안써도 된다.\nelem.addEventListener(..., true);\n```\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}